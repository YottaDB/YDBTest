#!/usr/bin/expect -f
#################################################################
#								#
# Copyright (c) 2018 YottaDB LLC and/or its subsidiaries.	#
# All rights reserved.						#
#								#
#	This source code contains the intellectual property	#
#	of its copyright holder(s), and is made available	#
#	under a license.  If you do not know the terms of	#
#	the license, please stop and do not read further.	#
#								#
#################################################################
# This module is derived from FIS GT.M.
#################################################################
#
# This Expect script was generated by autoexpect on Thu Feb 17 11:39:44 2011
# Expect and autoexpect were both written by Don Libes, NIST.
#
# Note that autoexpect does not guarantee a working script.  It
# necessarily has to guess about certain things.  Two reasons a script
# might fail are:
#
# 1) timing - A surprising number of programs (rn, ksh, zsh, telnet,
# etc.) and devices discard or ignore keystrokes that arrive "too
# quickly" after prompts.  If you find your new script hanging up at
# one spot, try adding a short sleep just before the previous send.
# Setting "force_conservative" to 1 (see below) makes Expect do this
# automatically - pausing briefly before sending each character.  This
# pacifies every program I know of.  The -c flag makes the script do
# this in the first place.  The -C flag allows you to define a
# character to toggle this mode off and on.

set force_conservative 0  ;# set to 1 to force conservative mode even if
			  ;# script wasn't run conservatively originally
if {$force_conservative} {
	set send_slow {1 .1}
	proc send {ignore arg} {
		sleep .1
		exp_send -s -- $arg
	}
}

#
# 2) differing output - Some programs produce different output each time
# they run.  The "date" command is an obvious example.  Another is
# ftp, if it produces throughput statistics at the end of a file
# transfer.  If this causes a problem, delete these patterns or replace
# them with wildcards.  An alternative is to use the -p flag (for
# "prompt") which makes Expect only look for the last line of output
# (i.e., the prompt).  The -P flag allows you to define a character to
# toggle this mode off and on.
#
# Read the man page for more info.
#
# -Don

set gtm_verno		[lindex $argv 0]
set gtm_image		[lindex $argv 1]
set gtm_test_ver	[lindex $argv 2]

# Count PASS/FAIL
set pass 0
set fail 0

proc passfail {iters} {
	global fail
	global pass
	while {$iters > 0} {
		expect {
			"PASS" {incr pass 1}
			"FAIL" {incr fail 1}
		}
		incr iters -1
	}
}

# BEGIN

set timeout -1
spawn $env(SHELL)
match_max 100000
expect "*"
send -- "set prompt=\"D9F05002548>\"\r"
expect "*"
expect -- "D9F05002548>"
send -- "uname -a\r"

expect {
	# HPUX is teh stupids
	"HP-UX" {
		send -- "stty -a\r"
		expect -- "D9F05002548>"
		send -- "stty erase '^?'\r"
		expect -- "D9F05002548>"
		send -- "stty intr '^c'\r"
		expect -- "D9F05002548>"
		send -- "stty -a\r"
	}
	"*" {send -- "\r"}
}

#### TEST STARTS HERE ###

expect -- "D9F05002548>"
send -- "/gtc/staff/gtm_test/current/$gtm_test_ver/manual_tests/u_inref/D9F05002548.csh $gtm_verno $gtm_image $gtm_test_ver manual_tests\r"




expect "Input for X: "
send -- "inseftr\r"
expect "Input for Y : "
send -- "alvmOCOCern\r"
expect "Input for Z : "
send -- "oerstrikeOC\[2~v\[2~\r"

expect "PASTHRU\r
"
send -- "inseftr\r"

expect "Input for X: "
send -- "a"
send -- "OA\r"
send -- "works"

#echo "do btest^ttyread<ctrl-A><right><right><right>a"
expect "YDB>"
send -- "do btest^ttyread"
send -- "OCOCOCa\r"

expect "Input for X: "
send -- "fgfasdfgf\r"

expect "Single char input Y: "
send -- "OA"
expect "Five Char input Z: "
send -- "bcdfae"

expect "Input for X: "
send -- "apleODODps"
expect "Input for Y : "
send -- "qwertyuy\r"
expect "Input for Z : "
send -- "bOA"

expect "Input for X: "
send -- "inseftr\r"
expect "Input for Y : "
send -- "alvmOCOCern\r"
expect "Input for Z : "
send -- "oerstrikeOC\[2~v\[2~\r"

expect "Input for X: "
send -- "testing"
send -- ""
send -- ""
send -- "\r"

expect "Input for Y : "
send -- "testingOCOCOC\r"

expect "Input for Z : "
send -- "OA\r"

expect -exact "Input the following: backspace<ctrl A><3 ctrl F><del><ret>\r
"
send -- "backspace\r"
expect "Input the following: backspace<ctrl A><3 ctrl F><ctrl H><ret>\r
"
send -- "backspace\r"

expect "PASTHRU\r
"
send -- "inseftr\r"

expect "PASTHRU\r
"
send -- "mystrey\r"

expect "Input before<ret> :"
send -- "before\r"
expect "Input for Y :"
send -- "after\r"
expect "Input for Z :"
send -- "OA\r"


expect "YDB>"
send -- "do atest^ttyreadin\r"
expect "Input 1234<left> :"
send -- "1234\[D"

expect "YDB>"
send -- "sodo atest^ttyraODed\r"

#expect "12345678901234567<ctrl-A>a<ctrl-E>b<4 lefts><del>b<ctrl-B><ins>c<ret>"
expect -exact "***"
send -- "12345678901234567abODODODODb\[2~c\r"

expect "Input testing<ret> : "
send -- "testing\r"
expect "Input asdfgf<ctrl-A><Ctrl-F><right><Ctrl-B>\r
"
send -- "asdfgfOC"
expect "you typed one of the EDITING Control characters ^B, ^E, ^K\r
"
send -- ""
expect "you typed one of the EDITING Control characters ^B, ^E, ^K\r
"
send -- ""
expect "you typed one of the EDITING Control characters ^B, ^E, ^K\r
"
send -- ""

expect "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa:"
send -- "nowrap\r"

expect "GDE>"
send -- "show egrionOCOCOCOCOC-\r"
expect "GDE>"
send -- "wequit\r"
expect "GDE-I-NOACTION" {puts "PASS\r"}

expect "GDE>"
send -- "show -tegODODrion\r"
set timeout -1
expect "GDE>"
send -- "wewuitq\r"
expect "GDE-I-NOACTION" {puts "PASS\r"}


expect "GDE>"
send -- "quit\r"
expect "%GDE-E-ILLCHAR,  is not a legal character in this context\r
\r
GDE> " {puts "PASS\r"}
send -- "quit\r"
expect "GDE-I-NOACTION" {puts "PASS\r"}

expect "Input asdfg*
"
send -- "asdfg\[20~"
expect "Input asdfg*
"
send -- "asdfg\[20~\r"
send -- "\r"

expect -- "D9F05002548>"
send -- "exit\r"
expect eof

#puts "FAIL count $fail\r"
#puts "PASS count $pass\r"
