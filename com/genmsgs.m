;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;								;
;	Copyright 2014 Fidelity Information Services, Inc	;
;								;
; Copyright (c) 2017-2018 YottaDB LLC and/or its subsidiaries.	;
; All rights reserved.						;
;								;
;	This source code contains the intellectual property	;
;	of its copyright holder(s), and is made available	;
;	under a license.  If you do not know the terms of	;
;	the license, please stop and do not read further.	;
;								;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Triggers generation of all messages whose information is recorded in a specified file, via the means of ZMESSAGE. ;
; Depending on whether a particular white-box test is enabled, messages can be printed either in the terminal or in ;
; the syslog. To invoke this file, do                                                                               ;
;                                                                                                                   ;
;   mumps -run genmsgs <message filename> <arguments filename>.cmp [<pid filename>.log]                             ;
;                                                                                                                   ;
; where <message filename> is the name of the M routine containing message information produced by getmsginfo.m     ;
; (do not provide the extension); <arguments filename> is the name of the file where arguments used to produce each ;
; of the messages are stored; and <pid filename> (optional) is the name of the file where the PID of the process    ;
; needs to be saved.                                                                                                ;
;                                                                                                                   ;
; If the messages are sent to the syslog, this script also prints the mnemonic of the last message, so that it can  ;
; be verified whether the syslog daemon has processed the entire batch of them.                                     ;
;                                                                                                                   ;
; NOTE: Argument generation is based on the types currently used in any of the GT.M messages. If some new type is   ;
; introduced, it needs to be added here.                                                                            ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
genmsgs
	new i,msgFile,argsOut,pidFile,mnemonic,id,count,type,arg,messages,expValue,is64Bit,inSyslog,isZGBLDIRACC,debug

	set debug=0
	set $etrap="use $principal zshow ""*"" halt"
	set is64Bit=$$is64Bit()

	; Get the message information; characters used for tab and newline substitution are irrelevant.
	set msgFile=$piece($zcmdline," ",1)
	set msgFile="setMsgInfo^"_msgFile
	do @msgFile@(.messages,$char(9),", ")

	; Open the output file and write the label name.
	set argsOut=$piece($zcmdline," ",2)
	open argsOut:newversion
	if (debug) set dbg="debug.cmp" open dbg:newversion

	; If specified, use the file to save the process ID.
	set pidFile=$piece($zcmdline," ",3)
	if (""'=pidFile) do
	.	open pidFile:newversion
	.	use pidFile
	.	write $job
	.	close pidFile

	; The white-box test scenario #101 means that ZMESSAGEs are printed to the syslog. We care because ZMESSAGE pevents
	; certain types of messages from being generated by the means of rts_error(); send_msg(), on the other hand, is safe
	; to use for any kind of message. Additionally, when dealing with the syslog, we print the mnemonic of the last
	; processed message in $principal.
	set inSyslog=("101"=$ztrnlnm("gtm_white_box_test_case_number"))
	set mnemonic=""
	for  set mnemonic=$order(messages(mnemonic)) quit:(""=mnemonic)  do
	.	set id=messages(mnemonic,"id")
	.
	.	; Due to issues with piece collection from within an error trap, avoid simulating an
	.	; error condition altogether by making all messages' severity informational.
	.	set:("fatal"=messages(mnemonic,"severity")) id=id-1
	.	set:("error"=messages(mnemonic,"severity")) id=id+1
	.	set:("warning"=messages(mnemonic,"severity")) id=id+3
	.
	.	; Bypass messages that cannot be triggered via the ZMESSAGE command, unless sent to the terminal:
	.	; CTRAP, CTRLC, CTRLY, JOBINTRRETHROW, JOBINTRRQST, REPEATERROR, SPCLZMSG, STACKCRIT, TPRETRY, and UNSOLCNTERR.
	.	quit:('inSyslog)&((150372499=id)!(150372507=id)!(150372515=id)!(150380275=id)!(150379867=id)!(150379523=id)!(150382875=id)!(150373739=id)!(150376099=id)!(150375331=id))
	.
	.	; Precede the list of arguments with the mnemonic of the message that they are purposed for.
	.	if (debug) use dbg write mnemonic,!
	.	use argsOut
	.	write mnemonic,!
	.
	.	; Generate the required number of arguments for the current message.
	.	set count=messages(mnemonic,"args")
	.	set cumul=1
	.	for i=1:1:count do
	.	.	set type=messages(mnemonic,"args",i,"type")
	.	.	set arg(i)=$$generateArg(type,.expValue)
	.	.	write expValue
	.	.	if (""=messages(mnemonic,"args",i,"postChars")) do
	.	.	.	if $incr(cumul)
	.	.	else  do
	.	.	.	for j=1:1:cumul write !
	.	.	.	set cumul=1
	.	.	if (debug) use dbg write arg(i),! use argsOut
	.
	.	write !
	.	if (debug) use dbg write !
	.	use $principal
	.
	.	; Currently zmessage bombs with indirection (until GTM-6114 is fixed), so the workaround is to use 21 explicit arguments
	.	; (the max number of arguments used in a message is for JNLBUFINFO), some of which might be empty. An alternative would be to use XECUTE,
	.	; but it prints some redundant stuff.
	.	for i=i+1:1:21 set arg(i)=""
	.
	.	; Actually print the message.
	.	zmessage id:arg(1):arg(2):arg(3):arg(4):arg(5):arg(6):arg(7):arg(8):arg(9):arg(10):arg(11):arg(12):arg(13):arg(14):arg(15):arg(16):arg(17):arg(18):arg(19):arg(20):arg(21)

	use $principal

	; Print the last processed message in case they are targeted to the syslog.
	if (inSyslog) write $order(messages(mnemonic),-1)

	close argsOut

	quit

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Generate an argument of a specific type (such as 'AD' or 'UL'), taking the width into consideration.              ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
generateArg(type,expValue)
	new i,fullType,value,firstChar,secondChar,width,indirection,sign,signedValue,binary,length,xWidth,fillChar

	; Record the requested width of the argument and remove the indirection sign.
	set fullType=type
	set width="",indirection=0
	set:("n"=$extract(type)) width=+$extract(type,2,10),type=$extract(type,2+$length(width),10)
	set:("@"=$extract(type)) indirection=1,type=$extract(type,2,10)

	set firstChar=$extract(type)
	set secondChar=$extract(type,2)

	if (indirection) do
	.	set signedValue=$$generateRandomNum()
	.	set sign=(0<signedValue)*2-1
	.	set value=sign*signedValue
	.
	.	if ("Q"=secondChar) do
	.	.	; Since values produced by generateRandomNum() should not exceed 18 digits, there is no reason
	.	.	; to enforce a 64-bit binary (which is 20 digits long), but we are doing just to be consistent
	.	.	; with the rest of the logic happening below.
	.	.	set binary=$$signedBinary(value,64)
	.	.	if ("X"=firstChar) do				; !@XQ
	.	.	.	set expValue=$$convert(binary,2,16)
	.	.	else  if ("Z"=firstChar) do			; !@ZQ
	.	.	.	set expValue=$$convert(binary,2,10)
	.	.	else  if ("U"=firstChar) do			; !@UQ
	.	.	.	set expValue=$$convert(binary,2,10)
	.	.	else  do
	.	.	.	set expValue="TYPE NOT IMPLEMENTED: "_fullType
	.	else  do
	.	.	set expValue="TYPE NOT IMPLEMENTED: "_fullType
	else  if ("A"=firstChar) do
	.	; For any of the string types simply generate a sequence of alphanumerics.
	.	set length=$random(9)+1
	.	set value=$$^%RANDSTR(length,,"AN")
	.
	.	; Currently we have no !mA{C,D,F,S,Z}-typed messages.
	.	if (0=+width) set expValue=value
	.	else  set expValue="TYPE NOT IMPLEMENTED: "_fullType
	else  do
	.	set signedValue=$$generateRandomNum()
	.	set sign=(0<signedValue)*2-1
	.	set value=sign*signedValue
	.
	.	set xWidth=0
	.	if ("B"=secondChar) do
	.	.	; For byte types we should be moding by 256, but we want to occasionally generate values
	.	.	; exceeding the permitted range.
	.	.	set value=sign*(value#300)
	.	.	; AND with 0xFF (255) to take care of overflows and negatives.
	.	.	set binary=$$signedBinary(value,8)
	.	.	if ("X"=firstChar) do				; !XB
	.	.	.	set expValue=$$convert(binary,2,16)
	.	.	.	set xWidth=2
	.	.	else  do
	.	.	.	set expValue="TYPE NOT IMPLEMENTED: "_fullType
	.	else  if ("W"=secondChar) do
	.	.	; For word types we should be moding by 65536, but we want to occasionally generate values
	.	.	; exceeding the permitted range.
	.	.	set value=sign*(value#70000)
	.	.	; AND with 0xFFFF (65535) to take care of overflows and negatives.
	.	.	set binary=$$signedBinary(value,16)
	.	.	if ("X"=firstChar) do				; !XW
	.	.	.	set expValue=$$convert(binary,2,16)
	.	.	.	set xWidth=4
	.	.	else  do
	.	.	.	set expValue="TYPE NOT IMPLEMENTED: "_fullType
	.	else  if ("L"=secondChar) do
	.	.	; For double-word types we should be moding by 4294967295, but we want to occasionally generate
	.	.	; values exceeding the permitted range.
	.	.	set value=sign*(value#4300000000)
	.	.	; AND with 0xFFFFFFFF (4294967295) to take care of overflows and negatives.
	.	.	set binary=$$signedBinary(value,32)
	.	.	if ("X"=firstChar) do				; !XL
	.	.	.	set expValue=$$convert(binary,2,16)
	.	.	.	set xWidth=8
	.	.	else  if ("S"=firstChar) do			; !SL
	.	.	.	set sign=1-((+$extract(binary,1))*2)
	.	.	.	if (0>sign) do
	.	.	.	.	; In case of negatives, calculate the two's complement.
	.	.	.	.	set expValue=""
	.	.	.	.	for i=1:1:$length(binary) set expValue=expValue_(1-(+$extract(binary,i)))
	.	.	.	.	set expValue=-($$convert(expValue,2,10)+1)
	.	.	.	else  set expValue=$$convert(binary,2,10)
	.	.	else  if ("U"=firstChar) do			; !UL
	.	.	.	set expValue=$$convert(binary,2,10)
	.	.	else  do
	.	.	.	set expValue="TYPE NOT IMPLEMENTED: "_fullType
	.	else  if ("J"=secondChar) do
	.	.	if (is64Bit) do
	.	.	.	set binary=$$signedBinary(value,64)
	.	.	.	if ("X"=firstChar) do			; !XJ
	.	.	.	.	set expValue=$$convert(binary,2,16)
	.	.	.	.	set xWidth=16
	.	.	.	else  if ("U"=firstChar) do		; !UJ
	.	.	.	.	set expValue=$$convert(binary,2,10)
	.	.	.	else  do
	.	.	.	.	set expValue="TYPE NOT IMPLEMENTED: "_fullType
	.	.	else  do
	.	.	.	; For quad-word types on 32-bit machines we should be moding by 4294967295, but we want to
	.	.	.	; occasionally generate values exceeding the permitted range.
	.	.	.	set value=sign*(value#4300000000)
	.	.	.	; AND with 0xFFFFFFFF (4294967295) to take care of overflows and negatives.
	.	.	.	set binary=$$signedBinary(value,32)
	.	.	.	if ("X"=firstChar) do			; !XJ
	.	.	.	.	set expValue=$$convert(binary,2,16)
	.	.	.	.	set xWidth=8
	.	.	.	else  if ("U"=firstChar) do		; !UJ
	.	.	.	.	set expValue=$$convert(binary,2,10)
	.	.	.	else  do
	.	.	.	.	set expValue="TYPE NOT IMPLEMENTED: "_fullType
	.	; Hexadecimal characters are printed such that all unused most significant digits (up to the maximum number
	.	; of digits that a value of a particular type can have) are zeroed out.
	.	if ("X"=firstChar)&($length(expValue)<xWidth) do
	.	.	for  set expValue="0"_expValue quit:($length(expValue)=xWidth)

	; If there is a width involved, then for !X... and !Z... type arguments, the missing room is filled with zeroes;
	; otherwise, spaces are used.
	if ("X"=firstChar)!("Z"=firstChar) set fillChar="0"
	else  set fillChar=" "

	; Inflate up to the required width.
	if (expValue'["TYPE NOT IMPLEMENTED")&(0<+width) do
	.	if ($length(expValue)>width) do
	.	.	set expValue=""
	.	.	for i=1:1:width set expValue=expValue_"*"
	.	else  do
	.	.	for  quit:($length(expValue)>=+width)  set expValue=fillChar_expValue

	quit value

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Generate a random integer in the range of (-10^19; 10^19).                                                        ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
generateRandomNum()
	new length,value

	set length=$random(18)+1
	for  set value=+$$^%RANDSTR(length,,"N") quit:(length=$length(value))
	quit ($random(2)*2-1)*value

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Represent a number in two's complement notation and truncate it at a specific width.                              ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
signedBinary(x,width)
	new i,negative,binary,newBinary

	set negative=(x<0)
	if ('negative) set binary=$$convert(x,10,2) quit $$fill(.binary,width,0)
	set x=-x,binary=$$convert(x-1,10,2)
	set newBinary=""
	for i=1:1:$length(binary) quit:(1=+$extract(binary,i))
	set binary=$extract(binary,i,$length(binary))
	for i=1:1:$length(binary) set newBinary=newBinary_(1-(+$extract(binary,i)))
	quit $$fill(.newBinary,width,1)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Prefix a string with a particular character up to the specified width. If the string is longer than that width,   ;
; it is truncated to match the width.                                                                               ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
fill(string,width,digit)
	new i,length,prefix

	set length=width-$length(string)
	set prefix=""
	for i=1:1:length set prefix=prefix_digit
	set string=prefix_string
	if (width<$length(string)) do
	.	set i=$length(string)-width
	.	set string=$extract(string,i+1,$length(string))
	quit string

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Convert n from base y to base z.                                                                                  ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
convert(n,y,z)
	new value

	set value="",n=$$decimal(n,y)
	quit:(z=10) n
	for  set i=n#z,n=n\z,value=$select((i>9):$extract("ABCDEF",i-9),1:i)_value quit:(0=n)
	quit value

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Convert x from base y to base 10.                                                                                 ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
decimal(x,y)
	new i,value

	quit:(y=10) x
	set value=0
	for i=1:1:$length(x) set value=value*y+($find("0123456789ABCDEF",$extract(x,i))-2)
	quit value

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Indicate whether this version of GT.M is 64-bit or not.                                                           ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
is64Bit()
	if ($zversion["x86") quit:($zversion["64") 1 quit 0
	quit:($zversion["aarch64") 1
	quit:($zversion["AIX") 1
	quit:($zversion["OSF1") 0
	quit:($zversion["Solaris") 1
	quit:($zversion["IA64") 1
	quit 0
