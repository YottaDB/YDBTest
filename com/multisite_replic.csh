#!/usr/local/bin/tcsh -f
#################################################################
#								#
# Copyright (c) 2006-2016 Fidelity National Information		#
# Services, Inc. and/or its subsidiaries. All rights reserved.	#
#								#
# Copyright (c) 2018 YottaDB LLC. and/or its subsidiaries.	#
# All rights reserved.						#
#								#
#	This source code contains the intellectual property	#
#	of its copyright holder(s), and is made available	#
#	under a license.  If you do not know the terms of	#
#	the license, please stop and do not read further.	#
#								#
#################################################################
############################################################################################################
# This script will be the backbone for all multisite_replic related actions. We will call an AWK script here
# to read the multisite_config file and set up the directory layout
# A script generated by the AWK will then be sourced finally to carry out the requested multisite action
############################################################################################################
# The following are the functions offered by he multisite_replic script
# - RUN link_or_instance_arg <command>
# - START link [RP|PP] (Root Primary|Propagating Primary)
# - STOP link or instance
# - CRASH instance
# - STARTRCV (Start Receiver) link [option]
# - STARTSRC (Start Source) link [RP|PP]
# - STOPRCV (Stop Receiver) link
# - STOPSRC (Stop Source) link
# - SYNC link
# - STOP ALL_LINKS
# - SYNC ALL_LINKS
# - CHECKHEALTH link
# - SHOWBACKLOG link
# - ACTIVATE link [RP|PP]
# - REFRESHLINK link
############################################################################################################
# The argument layout for the above functions will be like
# MSR [STOP|STARTRCV|STOPSRC|STOPRCV|SYNC|CHECKHEALTH|SHOWBACKLOG|REFRESHLINK] instance_source instance_receiver
# MSR [CRASH|STOP] instance
# MSR [START|STARTSRC|ACTIVATE] instance_source instance_receiver [RP|PP]
# MSR RUN link_or_instance_arg <command>
# MSR [SYNC|STOP] ALL_LINKS
############################################################################################################
# ALIASES and ENVIRONMENT variables that will assist in MSR coding (can be found in multisite_replic_prepare_base.csh)
# $MSR - to do a multisite action. The variable will call multisite_replic.csh which in turn the AWK and get processed
# $MULTISITE_REPLIC_ENV - to be used after every multisite_replic_preparation to set the environment variables
# get_msrtime - To get the timestamp of the last executed msr action.
# Will be helpful to know the name of the outfiles from that action like SRC_{$time_msr}.out. $time_msr is the variable that will hold the value of the time stamp for this alias execution
# msr_err_chk - used to check whether an expected error exist or not in the logfiles. Calls check_error_exist.csh
############################################################################################################
# MISC OPTIONS:
############################################################################################################
#	-----------------
# 	msr_dont_chk_stat
#	-----------------
# msr framework will check for $status on the multisite action we request for and report error for anyhting other than 0
# But in some cases we do expect non-zero status like diff between two extracts or listings or such
# In those case pls. make use of var. $msr_dont_chk_stat. If the scripts finds
# the set of msr_dont_chk_stat in the msr_execute_xx.csh it generates it avoids checking status
# Sample usage: $MSR RUN INST1 'set msr_dont_chk_stat;diff INST1_xxx.glo INST2_xxx.glo'
# If it is not on RUN but on regular MSR actions we need this feature then we have to setenv this variable before
# invoking that particular function
# Sample usage:
# setenv msr_dont_chk_stat
# $MSR START X Y
# if we know X Y is going to fail
#
#	-----------------
# 	msr_dont_trace
#	-----------------
# Every MSR action executed will be logged in the outfile as to what it is executing like $MSR STARTRCV INST1 ....
# This might be too noisy at times especially with simple RUN commands.
# To turn off logging for those cases use var. msr_dont_trace as apart of your RUN command
# Sample usage: $MSR RUN INST1 'set msr_dont_trace;diff INST1_xxx.glo INST2_xxx.glo'
# > -output option
# To capture the output of a MSR action in a user specified outfile pls. make use of -output option
# Sample usage: $MSR STARTRCV INST1 INST2 -output=rcvr_start.out
# This will log the output in rcvr_start.out in addition to logging them in those $gtm_test_replic_timestamp characterized outfiles.
#
#	--------------------
# 	msr_execute_last_out
#	--------------------
# Sometimes we would like to filter the error messages which we expect during the flow of a test,otherwise test system
# error catching mechanism reports it at the end which we don't want.And for msr action we know the errors get logged in
# msr_execute_x.out.But which "x"? So to capture the output of last msr action make use of msr_execute_last_out variable
# this will hold the name of the last executed msr_execute.csh
# NOTE : If the MSR RUN command output is redirected to pipe, it is executed in a subshell and so the new value of
# msr_execute_last_out will not be reflected. The workaround is to not redirect the entire output to pipe. e.g, for the below
# $MSR RUN INST2 "$msr_err_chk $rcv_logfile 'YDB-E-REPLNOTLS'" |& sed 's/RCVR.*log/#FILTERED#/g'
# Since entire output is redirected to pipe, $msr_execute_last_out will not have the latest value, but the previous value
#
#	-----------------
# 	RESERVEPORT option
#	-----------------
# If we want to reserve a portno of a link even after shutting it down for some reasons make use of RESERVEPORT OPTION alongwith STOP actions like $MSR STOP INST1 INST2 RESERVEPORT or $MSR STOPRCV INST1 INST3 RESERVEPORT etc.
# This option will not update the config files after shutdown and will NOT remove the /tmp/ portno files.So ensure we do a dbcheck or something at the end to take care of that
# We can reuse the reserved ports using STARTSRC and STARTRCV actions.However START will not.
#
#	------------------------------
# 	To copy files across instances
#	------------------------------
# There will be many instances involved and we will need to copy files across them.To do that make use of $MSR RUN option . A sample usage is
# $MSR RUN SRC=INST1 RCV=$cur_ins '$gtm_tst/com/cp_remote_file.csh _REMOTEINFO___RCV_DIR__/'$cur_ins'_${extract_time}.glo __SRC_DIR__/'
# cp_remote_file.csh will take care of expanding REMOTEINFO so pls. keep the usage the same way as it is above
#
#	----------------------------------------------------------
#	To refresh a change in environment variable to remote side
#	----------------------------------------------------------
# If the environment change is permanent throughout the test, then the below is a good way to do
# setenv gtm_test_xxx "new value set in subtest"
# setenv >&! env.txt
# foreach instx (`echo $gtm_test_msr_all_instances|sed 's/INST1 //g'`)
#	$MSR RUN SRC=INST1 RCV=$instx 'setenv INSTXNAME __RCV_INSTNAME__; $gtm_tst/com/send_env.csh'
# end
#
# On the other hand, if temporarily changes has to be propagated, or have different values at different instances,
# the below would be a better choice
#
# $MSR RUN INST1 'set msr_dont_trace ; echo setenv gtm_test_xxx "new value for INST1" >> env_supplementary.csh'
# $MSR RUN INST2 'set msr_dont_trace ; echo setenv gtm_test_xxx "new value for INST2" >> env_supplementary.csh'
#
############################################################################################################
#
if ( 2 > $#argv ) then
	echo "TEST-E-MULTIWAY_REPLIC error. Pls. specify an action and an instance or link to work on"
	echo "Sample usage:"
	echo "MULTIWAY_REPLIC START <link_or_ins>"
	exit 1
endif
# save the current dir from where we execute MSR action. This will be restored at all exit points.
set cur_dir=`pwd`
cd $tst_working_dir
#
set arg1=$1;set arg2=$2;set arg3="$3"
set links_file = msr_active_links.txt
set ins_file = msr_instance_config.txt
set log_file = multisite_replic.log
set UNSET="unsetenv gtm_test_replic_timestamp action_file portno del_update_port add_update_port close_all_ports dont_release_port msr_dont_chk_stat"
set short_host = $HOST:ar
if !( -e $links_file ) then
#	This entry is at the very beginning - first time an msr action is requested for
	touch $links_file
endif
#
# we need this check because MSR calls another MSR before the former completes
if ($?action_file) then
	setenv save_action_file $action_file
	setenv save_gtm_test_replic_timestamp $gtm_test_replic_timestamp
endif
set call_count = `ls msr_execute*.csh |& $tst_awk -F '[._]' '{if ($3>a) a=$3} END {print a+1}'`
setenv action_file "msr_execute_$call_count"
# note down a common time stamp for the multisite action here. This wil be used in all the logs generated by the msr action
setenv gtm_test_replic_timestamp `date +%H_%M_%S`"_$call_count"

# Begin multisite logging here
echo "############################################################################" >>&! $log_file
echo "#" >>&! $log_file
if ( "$argv" =~ *msr_dont_trace* ) then
	echo "==Executing MULTISITE_REPLIC '$argv'==" >>&! $log_file
else
	echo "==Executing MULTISITE_REPLIC '$argv'==" |tee -a $log_file
endif
#
$tst_awk -f $gtm_tst/com/multisite_replic.awk -v arguments="$argv" -v scriptname="$action_file" $ins_file $links_file  $gtm_tst/com/multisite_action_command.lis >&! $action_file".csh"
################################# error reporting section ##################################
source $gtm_tst/com/chk_msr_errors.csh $arg1
if ( 1 == $status ) then
	echo "TEST-E-MULTISITE REPLIC ERROR. Pls. check the accompanying message for the exact cause"
	$UNSET
	cd $cur_dir;exit 1
endif
################################# end of error reporting section ##################################
#
echo "Environment setup and the multisite action executed will be found in $action_file.csh (and $action_file.out) as" >>&! $log_file
echo "TIMESTAMP: for this msr_action is $gtm_test_replic_timestamp" >>&! $log_file
################################# multiple hosts section ##################################
# collect the environment details into a file
# check whether we have multiple hosts involved in our msr action in order to ship the environment file prepared
# Some little THEORY on what we do here.
#####
# Except for ALL_LINKS action all we do below is to
# > collect all "setenv" env. settings from msr_execute_xx.csh into a separate script
# > modify [pri,sec]_getenv setting in msr_execute_xx.csh in such a way that it sources the file prepared in the above step
# > copy the env file (it's called env_suppl_msr_execute_xxx.csh) to the remote host remote dir location
# > source the msr_execute_xx.csh ordinarily like we do for single host tests.The modifed [pri,sec]_getenv will take care
#  of setting up the env after logging into the appropriate shell.
############################################################################################################################
# Now for ALL_LINKS part of the msr action in addition to the above steps we need the following extra
# > since there is only one msr_execute_xx.csh prepared for ALL_LINKS there will be numerous separate set of environments
# prepared for each and every action in an orderly fashion in the same script.
# the env_suppl_msr_execute_xxx should be intelligent enough to slice out only the required piece of the env for a
# given action
# > since there will be many [pri,sec]_getenv's in that one script proper substituion has to be made for each of them based on the host and its remote dir's.
# > the logic below heavily depends on one thing though. That for any given side primary or secondary the set will be complete
# i.e. PRI_SIDE,pri_getenv,tst_now_primary etc. will all be there without anything missing as far as one set is concerned.
# that is only logical to believe as it is only a script that creates this msr_execute_xx.csh and it will be all or nothing
# for any given side. head and tail logic below mirrors this. #BYPASSOK
############################################################################################################################
if (0 == `$grep -c "The command to get executed is RUN" $action_file".csh"`) then
	set tot_count = `$tst_awk '/^setenv tst_now_primary/ {i++} END{print i+0}' $action_file.csh`
	set count = 1; set start_line = 1
	while ( $tot_count )
		set end_line=`$tst_awk '/COMMAND TO EXECUTE/ {a[++i]=NR} END {print a['$count']}' ${action_file}.csh`
		if ( 0 != `$tst_awk '/^setenv pri_shell/ {a[++i]=$0} END{if (a['$count'] !~ /tcsh -f -c/) {print 1}}' $action_file.csh`) then
			set fn=env_suppl_$action_file"_pri_$count.csh"
			echo "#\!/usr/local/bin/tcsh -f" >&! $fn
			echo "setenv gtm_test_replic_timestamp $gtm_test_replic_timestamp" >>&! $fn
			sed -n "$start_line,$end_line"p $action_file".csh"|$grep "^setenv "| $grep -v "_getenv" >>&! $fn
			set pri_host=`$tst_awk '/^setenv tst_now_primary/ { gsub(/"/,"") ; a[++i]=$3 } END {print a['$count']}' ${action_file}.csh`
			set tmp_pri_side=`$tst_awk '/^setenv PRI_SIDE/ { gsub(/"/,"") ; a[++i]=$3 } END {print a['$count']}' ${action_file}.csh`
			if ("$short_host" == "${pri_host:ar}") then
				if !(-e $tmp_pri_side/$fn) \cp $fn $tmp_pri_side/$fn
				if ($status) echo "MSR-E-CPFAIL cp $fn $tmp_pri_side/$fn failed"
			else
				$rcp $fn "$pri_host":$tmp_pri_side/$fn
				if ($status) echo "MSR-E-CPFAIL $rcp $fn "$pri_host":$tmp_pri_side/$fn failed"
			endif
			set line_no=`$tst_awk '/^setenv pri_getenv/ {a[++i]=NR} END {print a['$count']}' ${action_file}.csh`
			sed $line_no's#\(.*\)#\1";source '$tmp_pri_side'/'$fn'"#' $action_file".csh" >& tmp_$action_file".csh"
			mv tmp_$action_file".csh" $action_file".csh"
		endif
		set start_line = $end_line; @ tot_count-- ; @ count++
	end
	set tot_count = `$tst_awk '/^setenv tst_now_secondary/ {i++} END{print i+0}' $action_file.csh`
	set count = 1; set start_line = 1
	while ( $tot_count )
		set end_line=`$tst_awk '/COMMAND TO EXECUTE/ {a[++i]=NR} END {print a['$count']}' ${action_file}.csh`
		if ( 0 != `$tst_awk '/^setenv sec_shell/ {a[++i]=$0} END{if (a['$count'] !~ /tcsh -f -c/) {print 1}}' $action_file.csh`) then
			set fn=env_suppl_$action_file"_sec_$count.csh"
			echo "#\!/usr/local/bin/tcsh -f" >&! $fn
			echo "setenv gtm_test_replic_timestamp $gtm_test_replic_timestamp" >>&! $fn
			sed -n "$start_line,$end_line"p $action_file".csh"|$grep "^setenv "| $grep -v "_getenv" >>&! $fn
			set sec_host=`$tst_awk '/^setenv tst_now_secondary/ { gsub(/"/,"") ; a[++i]=$3 } END {print a['$count']}' ${action_file}.csh`
			set tmp_sec_side=`$tst_awk '/^setenv SEC_SIDE/ { gsub(/"/,"") ; a[++i]=$3 } END {print a['$count']}' ${action_file}.csh`
			if ("$short_host" == "${sec_host:ar}") then
				if !(-e $tmp_sec_side/$fn) \cp -f $fn $tmp_sec_side/$fn
				if ($status) echo "MSR-E-CPFAIL cp -f $fn $tmp_sec_side/$fn failed"
			else
				$rcp $fn "$sec_host":$tmp_sec_side/$fn
				if ($status) echo "MSR-E-CPFAIL $rcp $fn "$sec_host":$tmp_sec_side/$fn failed"
			endif
			set line_no=`$tst_awk '/^setenv sec_getenv/ {a[++i]=NR} END {print a['$count']}' ${action_file}.csh`
			sed $line_no's#\(.*\)#\1";source '$tmp_sec_side'/'$fn'"#' $action_file".csh" >& tmp_$action_file".csh"
			mv tmp_$action_file".csh" $action_file".csh"
		endif
		set start_line = $end_line; @ tot_count-- ; @ count++
	end
	# the condition below is for portno handling across multiple hosts
	# one: check if it is multiplehost and env_suppl_xx.csh is created
	# two: check if portno_acquire.csh is sourced in the master script (msr_execute) and if yes pass that value to the
	# remote host and do not attempt to source portno_acquire.csh agaian there creating an all new portno.
	if ( ($?fn) && (`$grep -c -E "^setenv portno .*portno_acquire.csh" ${action_file}.csh`) ) then
		$tst_awk '{if ($0 ~ /##############################################/) {psub=1};if (psub) {sub("_getenv;","_getenv;setenv portno $portno;")} print}' $action_file.csh >& tmp_$action_file.csh
		mv tmp_$action_file.csh $action_file.csh
	endif
else
	# the action involved is RUN and now check for multiple hosts
	if ( 0 == `$grep -c "^$tst_tcsh \-c" $action_file".csh"` ) then
		set fn=env_suppl_$action_file"_run.csh"
		echo "#\!/usr/local/bin/tcsh -f" >&! $fn
		echo "setenv gtm_test_replic_timestamp $gtm_test_replic_timestamp" >>&! $fn
		$grep "^setenv " $action_file".csh"|& $grep -v "_getenv" >>&! $fn
		set tmp_host=`$grep "'setenv remote_ver " $action_file".csh"|$tst_awk 'gsub(/.setenv remote_ver.*/,"",$0 ) {print $NF}'`
		set tmp_side=`$grep "'setenv remote_ver " $action_file".csh"|$tst_awk -F";" 'gsub(/.*;;;cd /,"",$0) {print $1}'`
		set tmp_side=`echo $tmp_side|sed 's/\//\\\//g'`
		if ("$short_host" == "${tmp_host:ar}") then
			if ! (-e $tmp_side/$fn) \cp $fn $tmp_side/$fn
			if ($status) echo "MSR-E-CPFAIL cp $fn $tmp_side/$fn failed"
		else
			$rcp $fn "$tmp_host":$tmp_side/$fn
			if ($status) echo "MSR-E-CPFAIL $rcp $fn "$tmp_host":$tmp_side/$fn failed"
		endif
		sed 's/\(.setenv remote_ver.*;;;\)cd /\1source '$tmp_side'\/'$fn';cd /' $action_file".csh" >& tmp_$action_file".csh"
		mv tmp_$action_file".csh" $action_file".csh"
		# to avoid SSH hangs let's insert iput re-direction /dev/null to the RUN command
		if !( `$grep "'setenv remote_ver " $action_file".csh"|$grep "< \/dev\/null"|wc -l` ) then
			set quote="'"
			sed 's/\(.setenv remote_ver.*\)'$quote'/\1 < \/dev\/null'$quote'/' $action_file".csh" >& tmp_$action_file".csh"
			mv tmp_$action_file".csh" $action_file".csh"
		endif
	endif
endif
################################# end of multiple hosts section ##################################
#
cat $action_file".csh" >>&! $log_file
echo "############################################################################" >>&! $log_file
echo "#" >>&! $log_file
if ( $?test_debug ) cat $log_file
#
source $action_file".csh" >&! $action_file".out"
set act_stat=$status
if (!($?action_file)) then
	setenv action_file $save_action_file
	setenv gtm_test_replic_timestamp $save_gtm_test_replic_timestamp
endif
if ( -e $action_file".out" ) then
	$tst_awk '{if ((printact) && ($0 !~ /-----##############################################----/) && ($0 !~ /COMMAND TO EXECUTE.*/)) print;if ($0 ~ /-----##############################################----/) printact=1}' $action_file".out"
	echo "TIMESTAMP:$gtm_test_replic_timestamp" >>&! $action_file".out"
	setenv msr_execute_last_out $action_file".out"
else
	unsetenv msr_execute_last_out
endif
# output re-direction section as per user's request
if (0 != `echo "$argv"|$grep -c "\-output"` ) then
	set user_outfile=`echo "$argv"|sed 's/^.*output=//g'`
	set pri_out_stat sec_out_stat
	if ($?PRI_SIDE) then
		set pri_out_stat=`$pri_shell "$pri_getenv;ls $PRI_SIDE | $grep ${gtm_test_replic_timestamp}\. >&! /dev/null;echo "'$status'|$tail -n 1`
	endif
	if ($?SEC_SIDE) then
		set sec_out_stat=`$sec_shell "$sec_getenv;ls $SEC_SIDE | $grep ${gtm_test_replic_timestamp}\. >&! /dev/null;echo "'$status'|$tail -n 1`
	endif
	if ( 0 == $pri_out_stat) cat $PRI_SIDE/*${gtm_test_replic_timestamp}* >>&! $tst_working_dir/$user_outfile
	if ( 0 == $sec_out_stat) $sec_shell "$sec_getenv;cat $SEC_SIDE/*${gtm_test_replic_timestamp}\.*" >>&! $tst_working_dir/$user_outfile
	if ( 0 != $sec_out_stat && 0 != $pri_out_stat) echo "TEST-I-MULTISITE MSR "$argv" has no re-directed output to capture"
endif
if ( ($act_stat) && (0 == `$grep -c "msr_dont_chk_stat" $action_file.csh`) ) then
	if !($?msr_dont_chk_stat) echo "TEST-E-MULTISITE replic action failed.Pls. check $action_file.csh and all logs related to timestamp $gtm_test_replic_timestamp"
	# we need to ensure we cleanup /tmp port files for even failed START attempts
	# make the condition as tight as possible to avoid oops moments of removing the reservation for existing ports
	if ( ($?portno) && ($?add_update_port) ) then
		if ( 0 == `$grep -c $portno $ins_file` ) source $gtm_tst/com/remove_port.csh $portno
	endif
	$UNSET
	cd $cur_dir;exit $act_stat
endif
#
# save the links history
if ( 0 != $msr_error_chk ) then
	mv msr_links_temp.txt $links_file
	echo "############### Active Links for the state "$argv" at $gtm_test_replic_timestamp ###############" >>&! $tst_working_dir/msr_active_links_history.log
	cat $links_file >>&! $tst_working_dir/msr_active_links_history.log
endif
################################# portno update section ##################################
if !($?dont_release_port) then
	if ( $?add_update_port ) then
		# update the config file with new entries it could be two ways
		# - one add the port - two update the port
		# for updation part we also need to delete the previous reserved ports.
		set replace_port=`$tst_awk '/'$arg3'	PORTNO:/ {print $3}' $ins_file`
		if ( "UNINITIALIZED" != $replace_port && $replace_port != $portno ) then
			source $gtm_tst/com/remove_port.csh $replace_port $arg3
		endif
		sed 's/\('$arg3'	PORTNO:	\)'$replace_port'/\1'$portno'/g' $ins_file >&! /tmp/msr_instance_config_{$$}.txt
		mv /tmp/msr_instance_config_{$$}.txt $ins_file
		$MULTISITE_REPLIC_ENV
		# cleanup the flags
	else if ( $?del_update_port ) then
		# update the config file deleting old port entries
		foreach rcvr_list (`$tst_awk '/setenv del_update_port/ {print $3}' $action_file".csh"`)
			set rm_port=`$tst_awk '/'$rcvr_list'	PORTNO:	[0-9]/ {print $3}' $ins_file`
			# let's all remove the portfile reservations right away!!
			if ( "" != $rm_port ) source $gtm_tst/com/remove_port.csh $rm_port $rcvr_list
			sed 's/\('$rcvr_list'	PORTNO:	\)[0-9A-Z]*/\1UNINITIALIZED/g' $ins_file >&! /tmp/msr_instance_config_{$$}.txt
			mv /tmp/msr_instance_config_{$$}.txt $ins_file
		end
		$MULTISITE_REPLIC_ENV
	else if ( $?close_all_ports ) then
		# coming from STOP ALL_LINKS . delete remaining ports reserved if any by the test at this stage
		foreach ports (`$tst_awk '/PORTNO:	[0-9]/ {print $3}' $ins_file`)
			source $gtm_tst/com/remove_port.csh $ports
		end
		sed 's/PORTNO:	[0-9]*$/PORTNO:	UNINITIALIZED/g' $ins_file >&! /tmp/msr_instance_config_{$$}.txt
		mv /tmp/msr_instance_config_{$$}.txt $ins_file
		$MULTISITE_REPLIC_ENV
	endif
endif
$UNSET
cd $cur_dir;exit $act_stat
#
