# -------------------------------------------------------------------------------------------------------------
# Test M commands to serialize/deserialize local or global variable subtree
# -------------------------------------------------------------------------------------------------------------

### Test 0: Test ZYENCODE and ZYDECODE compilation errors 
## T0a: Compile [ydb1152.m] routine
# Expect a series of compilation errors.
		zyen dst(1,=src ; 46
		           ^-----
		At column 13, line 38, source module ##IN_TEST_PATH##/inref/ydb1152.m
%YDB-E-EXPR, Expression expected but not found
		zyen ^dst(1,=src ; 62
		            ^-----
		At column 14, line 40, source module ##IN_TEST_PATH##/inref/ydb1152.m
%YDB-E-EXPR, Expression expected but not found
		zyen @lhs@ ; 80
		          ^-----
		At column 12, line 42, source module ##IN_TEST_PATH##/inref/ydb1152.m
%YDB-E-LPARENMISSING, Left parenthesis expected
		zyen 123=src ; 108-109
		     ^-----
		At column 7, line 46, source module ##IN_TEST_PATH##/inref/ydb1152.m
%YDB-E-VAREXPECTED, Variable expected in this context
		zyen dst,=src ; 113-114
		        ^-----
		At column 10, line 48, source module ##IN_TEST_PATH##/inref/ydb1152.m
%YDB-E-EQUAL, Equal sign expected but not found
		zyen dst=src(1, ; 123
		               ^-----
		At column 17, line 50, source module ##IN_TEST_PATH##/inref/ydb1152.m
%YDB-E-EXPR, Expression expected but not found
		zyen dst=^src(1, ; 130
		                ^-----
		At column 18, line 52, source module ##IN_TEST_PATH##/inref/ydb1152.m
%YDB-E-EXPR, Expression expected but not found
		zyen @lhs=@rhs@ ; 138-139
		               ^-----
		At column 17, line 54, source module ##IN_TEST_PATH##/inref/ydb1152.m
%YDB-E-LPARENMISSING, Left parenthesis expected
		zyen dst=123 ; 151-152
		         ^-----
		At column 11, line 56, source module ##IN_TEST_PATH##/inref/ydb1152.m
%YDB-E-VAREXPECTED, Variable expected in this context
		zyde dst(1,=src ; 46
		           ^-----
		At column 13, line 65, source module ##IN_TEST_PATH##/inref/ydb1152.m
%YDB-E-EXPR, Expression expected but not found
		zyde ^dst(1,=src ; 62
		            ^-----
		At column 14, line 67, source module ##IN_TEST_PATH##/inref/ydb1152.m
%YDB-E-EXPR, Expression expected but not found
		zyde @lhs@ ; 80
		          ^-----
		At column 12, line 69, source module ##IN_TEST_PATH##/inref/ydb1152.m
%YDB-E-LPARENMISSING, Left parenthesis expected
		zyde 123=src ; 108-109
		     ^-----
		At column 7, line 73, source module ##IN_TEST_PATH##/inref/ydb1152.m
%YDB-E-VAREXPECTED, Variable expected in this context
		zyde dst,=src ; 113
		        ^-----
		At column 10, line 75, source module ##IN_TEST_PATH##/inref/ydb1152.m
%YDB-E-EQUAL, Equal sign expected but not found
		zyde dst=src(1, ; 123
		               ^-----
		At column 17, line 77, source module ##IN_TEST_PATH##/inref/ydb1152.m
%YDB-E-EXPR, Expression expected but not found
		zyde dst=^src(1, ; 130
		                ^-----
		At column 18, line 79, source module ##IN_TEST_PATH##/inref/ydb1152.m
%YDB-E-EXPR, Expression expected but not found
		zyde @lhs=@rhs@ ; 138-139
		               ^-----
		At column 17, line 81, source module ##IN_TEST_PATH##/inref/ydb1152.m
%YDB-E-LPARENMISSING, Left parenthesis expected
		zyde dst=123 ; 151-152
		         ^-----
		At column 11, line 83, source module ##IN_TEST_PATH##/inref/ydb1152.m
%YDB-E-VAREXPECTED, Variable expected in this context
		zyen dst(1,=src ; 46
		           ^-----
		At column 13, line 101, source module ##IN_TEST_PATH##/inref/ydb1152.m
%YDB-E-EXPR, Expression expected but not found
		zyen ^dst(1,=src ; 62
		            ^-----
		At column 14, line 103, source module ##IN_TEST_PATH##/inref/ydb1152.m
%YDB-E-EXPR, Expression expected but not found
		zyen @lhs@ ; 80
		          ^-----
		At column 12, line 105, source module ##IN_TEST_PATH##/inref/ydb1152.m
%YDB-E-LPARENMISSING, Left parenthesis expected
		zyen 123=src ; 108-109
		     ^-----
		At column 7, line 111, source module ##IN_TEST_PATH##/inref/ydb1152.m
%YDB-E-VAREXPECTED, Variable expected in this context
		zyen dst,=src ; 113-114
		        ^-----
		At column 10, line 113, source module ##IN_TEST_PATH##/inref/ydb1152.m
%YDB-E-EQUAL, Equal sign expected but not found
		zyen dst=src(1, ; 123
		               ^-----
		At column 17, line 115, source module ##IN_TEST_PATH##/inref/ydb1152.m
%YDB-E-EXPR, Expression expected but not found
		zyen dst=^src(1, ; 130
		                ^-----
		At column 18, line 117, source module ##IN_TEST_PATH##/inref/ydb1152.m
%YDB-E-EXPR, Expression expected but not found
		zyen @lhs=@rhs@ ; 138-139
		               ^-----
		At column 17, line 119, source module ##IN_TEST_PATH##/inref/ydb1152.m
%YDB-E-LPARENMISSING, Left parenthesis expected
		zyen dst=123 ; 151-152
		         ^-----
		At column 11, line 121, source module ##IN_TEST_PATH##/inref/ydb1152.m
%YDB-E-VAREXPECTED, Variable expected in this context
		zyde dst(1,=src ; 46
		           ^-----
		At column 13, line 154, source module ##IN_TEST_PATH##/inref/ydb1152.m
%YDB-E-EXPR, Expression expected but not found
		zyde ^dst(1,=src ; 62
		            ^-----
		At column 14, line 156, source module ##IN_TEST_PATH##/inref/ydb1152.m
%YDB-E-EXPR, Expression expected but not found
		zyde @lhs@ ; 80
		          ^-----
		At column 12, line 158, source module ##IN_TEST_PATH##/inref/ydb1152.m
%YDB-E-LPARENMISSING, Left parenthesis expected
		zyde 123=src ; 108-109
		     ^-----
		At column 7, line 165, source module ##IN_TEST_PATH##/inref/ydb1152.m
%YDB-E-VAREXPECTED, Variable expected in this context
		zyde dst=src(1, ; 123
		               ^-----
		At column 17, line 167, source module ##IN_TEST_PATH##/inref/ydb1152.m
%YDB-E-EXPR, Expression expected but not found
		zyde dst=^src(1, ; 130
		                ^-----
		At column 18, line 169, source module ##IN_TEST_PATH##/inref/ydb1152.m
%YDB-E-EXPR, Expression expected but not found
		zyde @lhs=@rhs@ ; 138-139
		               ^-----
		At column 17, line 171, source module ##IN_TEST_PATH##/inref/ydb1152.m
%YDB-E-LPARENMISSING, Left parenthesis expected
		zyde dst=123 ; 151-152
		         ^-----
		At column 11, line 173, source module ##IN_TEST_PATH##/inref/ydb1152.m
%YDB-E-VAREXPECTED, Variable expected in this context

## Test 0b: Various tests of code paths in sr_port/m_zyencode.c, sr_port/op_indzyencode.c, sr_port/op_zyencode.c, sr_port/op_zydecode.c, sr_port/m_zydecode.c, and sr_port/op_indzydecode.c.
## See also: https://gitlab.com/YottaDB/DB/YDB/-/merge_requests/1767#note_2956960973
## Run a series of commands and expect a series runtime error in each case.
# Run [s src("key")="value"]
# Run [s lhs="dst",rhs="src",sub=1]
# Run [zyen dst(1,=src ; 46]
ZSTATUS=T0b+11^ydb1152,%YDB-E-EXPR, Expression expected but not found
# Run [zyen ^dst(1,=src ; 62]
ZSTATUS=T0b+13^ydb1152,%YDB-E-EXPR, Expression expected but not found
# Run [zyen @lhs@ ; 80]
ZSTATUS=T0b+15^ydb1152,%YDB-E-LPARENMISSING, Left parenthesis expected
# Run [zyen @lhs ; 83-86]
ZSTATUS=T0b+17^ydb1152,%YDB-E-EQUAL, Equal sign expected but not found
# Run [zyen @lhs=src]
# Run [zyen 123=src ; 108-109]
ZSTATUS=T0b+21^ydb1152,%YDB-E-VAREXPECTED, Variable expected in this context
# Run [zyen dst,=src ; 113-114]
ZSTATUS=T0b+23^ydb1152,%YDB-E-EQUAL, Equal sign expected but not found
# Run [zyen dst=src(1, ; 123]
ZSTATUS=T0b+25^ydb1152,%YDB-E-EXPR, Expression expected but not found
# Run [zyen dst=^src(1, ; 130]
ZSTATUS=T0b+27^ydb1152,%YDB-E-EXPR, Expression expected but not found
# Run [zyen @lhs=@rhs@ ; 138-139]
ZSTATUS=T0b+29^ydb1152,%YDB-E-LPARENMISSING, Left parenthesis expected
# Run [zyen dst=123 ; 151-152]
ZSTATUS=T0b+31^ydb1152,%YDB-E-VAREXPECTED, Variable expected in this context
# Run [zyen dst(sub)=@rhs ; 162-164]
# Run [s src("key")="value"]
# Run [s rhs="src",at="@rhs"]
# Run [zyen dst=@at ; 76, 78-86]
# Run [s at=123]
# Run [zyen dst=@at ;]
ZSTATUS=T0b+44^ydb1152,%YDB-E-VAREXPECTED, Variable expected in this context
# Run [zyen ^lhs=^empty ; 103: make sure that ^empty has a $DATA of 0]
ZSTATUS=T0b+47^ydb1152,%YDB-E-ZYENCODESRCUNDEF, Error encountered during ZYENCODE; source variable must not be undefined
# Run [s ^src(1,$zch(136))=5]
# Run [zyen dst=@at ;]
##TEST_AWKZSTATUS=T0b\+51\^ydb1152,%YDB-W-ZYENCODEINCOMPL, Error encountered during ZYENCODE; operation may be incomplete,%YDB-E-JANSSONENCODEERROR, JSON encoding error: variable = \^src : subscript = \$[ZCH]*\(136\) : data = 5 - in ydb_encode_s\(\) call
# Run [s src(1,$zch(136))=5]
# Run [zyen dst=src(1) ; 355]
##TEST_AWKZSTATUS=T0b\+55\^ydb1152,%YDB-W-ZYENCODEINCOMPL, Error encountered during ZYENCODE; operation may be incomplete,%YDB-E-JANSSONENCODEERROR, JSON encoding error: variable = src : subscript = \$[ZCH]*\(136\) : data = 5 - in ydb_encode_s\(\) call
# Run [zyen ^dst=src(1) ; 450-458]
##TEST_AWKZSTATUS=T0b\+57\^ydb1152,%YDB-W-ZYENCODEINCOMPL, Error encountered during ZYENCODE; operation may be incomplete,%YDB-E-JANSSONENCODEERROR, JSON encoding error: variable = src : subscript = \$[ZCH]*\(136\) : data = 5 - in ydb_encode_s\(\) call
# Run [s src=1,src(1)="{""key":""value""}"]# Run [s lhs="dst",rhs="src",sub=1]
# Run [zyde dst(1,=src ; 46]
ZSTATUS=T0b+64^ydb1152,%YDB-E-EXPR, Expression expected but not found
# Run [zyde ^dst(1,=src ; 62]
ZSTATUS=T0b+66^ydb1152,%YDB-E-EXPR, Expression expected but not found
# Run [zyde @lhs@ ; 80]
ZSTATUS=T0b+68^ydb1152,%YDB-E-LPARENMISSING, Left parenthesis expected
# Run [zyde @lhs ; 83-86]
ZSTATUS=T0b+70^ydb1152,%YDB-E-EQUAL, Equal sign expected but not found
# Run [zyde @marray=@json ; 100-102] (also tests sr_port/format_key_mvals.c:48, per https://gitlab.com/YottaDB/DB/YDB/-/merge_requests/1767#note_2973059636)
ZSTATUS=T0b+73^ydb1152,%YDB-E-ZYDECODEDESC, ZYDECODE operation not possible: src(1) is a descendant of src
# Run [zyde 123=src ; 108-109]
ZSTATUS=T0b+75^ydb1152,%YDB-E-VAREXPECTED, Variable expected in this context
# Run [zyde dst=src(1, ; 123]
ZSTATUS=T0b+77^ydb1152,%YDB-E-EXPR, Expression expected but not found
# Run [zyde dst=^src(1, ; 130]
ZSTATUS=T0b+79^ydb1152,%YDB-E-EXPR, Expression expected but not found
# Run [zyde @lhs=@rhs@ ; 138-139]
ZSTATUS=T0b+81^ydb1152,%YDB-E-LPARENMISSING, Left parenthesis expected
# Run [zyde dst=123 ; 151-152]
ZSTATUS=T0b+83^ydb1152,%YDB-E-VAREXPECTED, Variable expected in this context
# Run [zyde dst(sub)=@rhs ; 162-164]
# Run [zyde dst=@at ; 76, 78-86]
# Run [zyde dst=@at ; 88]
ZSTATUS=T0b+93^ydb1152,%YDB-E-VAREXPECTED, Variable expected in this context
# Run [zyde dst=^src ; 275-281]
ZSTATUS=T0b+97^ydb1152,%YDB-E-ZYDECODEWRONGCNT, Error encountered during ZYDECODE; JSON chunk count in root of source variable must be a positive integer
# Run [zyde dst=^src ; 328-332]
ZSTATUS=T0b+100^ydb1152,%YDB-E-GVUNDEF, Global variable undefined: ^src(1)
# Run [zyde ^dst(1)=src ; 542-553, 561]
# Run [zyde ^dst=src ; 550-559]
ZSTATUS=T0b+106^ydb1152,%YDB-E-LVUNDEF, Undefined local variable: src(2)

#### Test 1: ZYENCODE error cases
# Run [set src("key1")="value1"]
# Run [set src("key1","key2")="value1"]
# Run [set ^src("key1")="value1"]
# Run [set ^src("key1","key2")="value1"]

### Test 1a: Source is descendant of destination (%YDB-E-ZYENCODEDESC)
# Run [zyencode src("key1")=src("key1","key2")]
# Expect '%YDB-E-ZYENCODEDESC, ZYENCODE operation not possible. src("key1","key2") is a descendant of src("key1")'
ZSTATUS=T1+16^ydb1152,%YDB-E-ZYENCODEDESC, ZYENCODE operation not possible: src("key1","key2") is a descendant of src("key1")
# Run [set x="a"]
# Run [zyencode x=x]
# Expect '%YDB-E-ZYENCODEDESC, ZYENCODE operation not possible. x is a descendant of x
ZSTATUS=T1+21^ydb1152,%YDB-E-ZYENCODEDESC, ZYENCODE operation not possible: x is a descendant of x

### Test 1b: Destination is descendant of source (%YDB-E-ZYENCODEDESC)
# Run [zyencode src("key1","key2")=src("key1")]'
# Expect '%YDB-E-ZYENCODEDESC, ZYENCODE operation not possible. src("key1","key2") is a descendant of src("key1")'
ZSTATUS=T1+27^ydb1152,%YDB-E-ZYENCODEDESC, ZYENCODE operation not possible: src("key1","key2") is a descendant of src("key1")
# Run [zyencode ^src("key1","key2")=^src("key1")]'
# Expect '%YDB-E-ZYENCODEDESC, ZYENCODE operation not possible. ^src("key1","key2") is a descendant of ^src("key1")'
ZSTATUS=T1+30^ydb1152,%YDB-E-ZYENCODEDESC, ZYENCODE operation not possible: ^src("key1","key2") is a descendant of ^src("key1")

### Test 1c: Undefined local variable passed as source raises %YDB-E-ZYENCODESRCUNDEF
# Run [zyencode dest=notanlvn]'
# Expect '%YDB-E-ZYENCODESRCUNDEF'
ZSTATUS=T1+36^ydb1152,%YDB-E-ZYENCODESRCUNDEF, Error encountered during ZYENCODE; source variable must not be undefined

### Test 1d: Errors from the underlying ydb_encode_s()
## Test $ZSTATUS is set and %YDB-W-ZYENCODEINCOMPL issued
# Run [set x=$ZCH(167)]
# Run [zyencode dest=x]
# Expect '%YDB-W-ZYENCODEINCOMPL' to be emitted with $ZSTATUS=%YDB-E-JANSSONENCODEERROR
##TEST_AWKZSTATUS=T1\+45\^ydb1152,%YDB-W-ZYENCODEINCOMPL, Error encountered during ZYENCODE; operation may be incomplete,%YDB-E-JANSSONENCODEERROR, JSON encoding error: variable = x : data = .* - in ydb_encode_s\(\) call
## Test invalid node value between multiple nodes at same subscript level
# Run [set ^y=3,^y(1)="value1",^y(2)=$ZCH(167),^y(3)="value3"]
# Run [zyencode z=^y]
# Expect '%YDB-W-ZYENCODEINCOMPL' to be emitted with $ZSTATUS=%YDB-E-JANSSONENCODEERROR
##TEST_AWKZSTATUS=T1\+52\^ydb1152,%YDB-W-ZYENCODEINCOMPL, Error encountered during ZYENCODE; operation may be incomplete,%YDB-E-JANSSONENCODEERROR, JSON encoding error: variable = \^y : subscript = 2 : data = .* - in ydb_encode_s\(\) call
# Run [zyencode z=^y(2)]
# Expect '%YDB-W-ZYENCODEINCOMPL' to be emitted with $ZSTATUS=%YDB-E-JANSSONENCODEERROR
##TEST_AWKZSTATUS=T1\+55\^ydb1152,%YDB-W-ZYENCODEINCOMPL, Error encountered during ZYENCODE; operation may be incomplete,%YDB-E-JANSSONENCODEERROR, JSON encoding error: variable = \^y : data = .* - in ydb_encode_s\(\) call
## Test invalid subscript value in separate subtree under a single root node
# Run [set ^y(1,2,3)=1,^y(4,$ZCH(167),6)=2]
# Run [zyencode z=^y]
# Expect '%YDB-W-ZYENCODEINCOMPL' to be emitted with $ZSTATUS=%YDB-E-JANSSONENCODEERROR
##TEST_AWKZSTATUS=T1\+62\^ydb1152,%YDB-W-ZYENCODEINCOMPL, Error encountered during ZYENCODE; operation may be incomplete,%YDB-E-JANSSONENCODEERROR, JSON encoding error: variable = \^y : subscript = .* - in ydb_encode_s\(\) call
## Test invalid subscript value in subtree under a single root node
# Run [set ^y(1)=1,^y(1,$ZCH(167))=2]
# Run [zyencode z=^y]
# Expect '%YDB-W-ZYENCODEINCOMPL' to be emitted with $ZSTATUS=%YDB-E-JANSSONENCODEERROR
##TEST_AWKZSTATUS=T1\+69\^ydb1152,%YDB-W-ZYENCODEINCOMPL, Error encountered during ZYENCODE; operation may be incomplete,%YDB-E-JANSSONENCODEERROR, JSON encoding error: variable = \^y : subscript = .* : data = 2 - in ydb_encode_s\(\) call
## Test invalid subscript value in subtree with its own subtree under a single root node
# Run [set ^y(1)=1,^y(1,$ZCH(167))=2,^y(1,$ZCH(167),3)=3]
# Run [zyencode z=^y]
# Expect '%YDB-W-ZYENCODEINCOMPL' to be emitted with $ZSTATUS=%YDB-E-JANSSONENCODEERROR
##TEST_AWKZSTATUS=T1\+76\^ydb1152,%YDB-W-ZYENCODEINCOMPL, Error encountered during ZYENCODE; operation may be incomplete,%YDB-E-JANSSONENCODEERROR, JSON encoding error: variable = \^y : subscript = .* - in ydb_encode_s\(\) call

#### Test 2: ZYDECODE error cases
# Run [set src("key1")="value1"]
# Run [set src("key1","key2")="value1"]
# Run [set ^src("key1")="value1"]
# Run [set ^src("key1","key2")="value1"]

### Test 2a: Source is descendant of destination (%YDB-E-ZYDECODEDESC)
# Run [zydecode src("key1")=src("key1","key2")]'
# Expect '%YDB-E-ZYDECODEDESC, ZYDECODE operation not possible. src("key1","key2") is a descendant of src("key1")'
ZSTATUS=T2+18^ydb1152,%YDB-E-ZYDECODEDESC, ZYDECODE operation not possible: src("key1","key2") is a descendant of src("key1")
# Expect '%YDB-E-ZYDECODEDESC, ZYDECODE operation not possible. ^src("key1","key2") is a descendant of ^src("key1")'
ZSTATUS=T2+20^ydb1152,%YDB-E-ZYDECODEDESC, ZYDECODE operation not possible: ^src("key1","key2") is a descendant of ^src("key1")

### Test 2b: Destination is descendant of source (%YDB-E-ZYDECODEDESC)
# Run [zydecode src("key1","key2")=src("key1")]'
# Expect '%YDB-E-ZYDECODEDESC, ZYDECODE operation not possible. src("key1","key2") is a descendant of src("key1")'
ZSTATUS=T2+26^ydb1152,%YDB-E-ZYDECODEDESC, ZYDECODE operation not possible: src("key1","key2") is a descendant of src("key1")
# Run [zydecode ^src("key1","key2")=^src("key1")]'
# Expect '%YDB-E-ZYDECODEDESC, ZYDECODE operation not possible. ^src("key1","key2") is a descendant of ^src("key1")'
ZSTATUS=T2+29^ydb1152,%YDB-E-ZYDECODEDESC, ZYDECODE operation not possible: ^src("key1","key2") is a descendant of ^src("key1")

### Test 2c: Various %YDB-E-ZYDECODEWRONGCNT scenarios
## T2c1: Root node of source = 0 (%YDB-E-ZYDECODEWRONGCNT)
# Run [set src=0]
# Run [zydecode dest=src("key1","key2")]'
# Expect '%YDB-E-ZYDECODEWRONGCNT'
ZSTATUS=T2+38^ydb1152,%YDB-E-ZYDECODEWRONGCNT, Error encountered during ZYDECODE; JSON chunk count in root of source variable must be a positive integer

## T2c2: Root node of source < 0 (%YDB-E-ZYDECODEWRONGCNT)
# Run [set src=-1]
# Run [zydecode dest=src("key1","key2")]'
# Expect '%YDB-E-ZYDECODEWRONGCNT'
ZSTATUS=T2+45^ydb1152,%YDB-E-ZYDECODEWRONGCNT, Error encountered during ZYDECODE; JSON chunk count in root of source variable must be a positive integer

## T2c3: Root node of source = non-numeric string (%YDB-E-ZYDECODEWRONGCNT)
# Run [set src="abc"]
# Run [zydecode dest=src("key1","key2")]'
# Expect '%YDB-E-ZYDECODEWRONGCNT'
ZSTATUS=T2+52^ydb1152,%YDB-E-ZYDECODEWRONGCNT, Error encountered during ZYDECODE; JSON chunk count in root of source variable must be a positive integer

## T2c4: Root node of source = positive floating point value (%YDB-E-ZYDECODEWRONGCNT)
# Run [set src=1.1]
# Run [zydecode dest=src("key1","key2")]'
# Expect '%YDB-E-ZYDECODEWRONGCNT'
ZSTATUS=T2+59^ydb1152,%YDB-E-ZYDECODEWRONGCNT, Error encountered during ZYDECODE; JSON chunk count in root of source variable must be a positive integer

## T2c5: Source is empty LVN, destination is empty GVN (%YDB-E-ZYDECODEWRONGCNT)
# Run [zydecode ^a=a]
# Expect '%YDB-E-ZYDECODEWRONGCNT'
ZSTATUS=T2+65^ydb1152,%YDB-E-ZYDECODEWRONGCNT, Error encountered during ZYDECODE; JSON chunk count in root of source variable must be a positive integer

## T2c6: Source is empty GVN, destination is the same GVN (%YDB-E-ZYDECODEWRONGCNT)
# Run [zydecode ^b=^b]
# Expect '%YDB-E-ZYDECODEWRONGCNT'
ZSTATUS=T2+71^ydb1152,%YDB-E-ZYDECODEWRONGCNT, Error encountered during ZYDECODE; JSON chunk count in root of source variable must be a positive integer

## T2c7: Source is empty LVN, destination is the same LVN (%YDB-E-ZYDECODEWRONGCNT)
# Run [zydecode b=b]
# Expect '%YDB-E-ZYDECODEWRONGCNT'
ZSTATUS=T2+77^ydb1152,%YDB-E-ZYDECODEWRONGCNT, Error encountered during ZYDECODE; JSON chunk count in root of source variable must be a positive integer

## T2c8: Source is empty LVN, destination is the different empty LVN (%YDB-E-ZYDECODEWRONGCNT)
# Run [zydecode c=d]
# Expect '%YDB-E-ZYDECODEWRONGCNT'
ZSTATUS=T2+83^ydb1152,%YDB-E-ZYDECODEWRONGCNT, Error encountered during ZYDECODE; JSON chunk count in root of source variable must be a positive integer

## T2c9: Source is empty LVN, destination is an empty GVN (%YDB-E-ZYDECODEWRONGCNT)
# Run [zydecode ^d=e]
# Expect '%YDB-E-ZYDECODEWRONGCNT'
ZSTATUS=T2+89^ydb1152,%YDB-E-ZYDECODEWRONGCNT, Error encountered during ZYDECODE; JSON chunk count in root of source variable must be a positive integer

## T2c10: Source is LVN set to 0 (explicitly indicating an empty JSON tree), destination is an empty GVN or LVN (%YDB-E-ZYDECODEWRONGCNT)
# Run [set d=0]
# Run [zydecode ^e=d]
# Expect '%YDB-E-ZYDECODEWRONGCNT'
ZSTATUS=T2+96^ydb1152,%YDB-E-ZYDECODEWRONGCNT, Error encountered during ZYDECODE; JSON chunk count in root of source variable must be a positive integer
# Run [zydecode e=d]
# Expect '%YDB-E-ZYDECODEWRONGCNT'
ZSTATUS=T2+99^ydb1152,%YDB-E-ZYDECODEWRONGCNT, Error encountered during ZYDECODE; JSON chunk count in root of source variable must be a positive integer

## Test 2d: LVN in series starting from root node's positive integer doesn't exist (%YDB-E-LVUNDEF)
# Run:
#  [kill]
#  [set src=3]
#  [set src(1)="{""key1"":""value1"","]
#  (skip setting src(2))
#  [set src(3)=""key3"":""value3""}"]
# Run [zydecode dest=src]'
# Expect '%YDB-E-LVUNDEF'
ZSTATUS=T2+115^ydb1152,%YDB-E-LVUNDEF, Undefined local variable: src(2)

## Test 2e: GVN in series starting from root node's positive integer doesn't exist (%YDB-E-GVUNDEF)
# Run:
#  [set ^src=3]
#  [set ^src(1)="{""key1"":""value1"","]
#  (skip setting ^src(2))
#  [set ^src(3)=""key3"":""value3""}"]
# Run [zydecode ^dest=^src]
# Expect '%YDB-E-GVUNDEF'
ZSTATUS=T2+130^ydb1152,%YDB-E-GVUNDEF, Global variable undefined: ^src(2)

## Test 2f: Error from the underlying ydb_decode_s(): $ZSTATUS is set and %YDB-W-ZYDECODEINCOMPL issued
# Expect '%YDB-W-ZYDECODEINCOMPL' to be emitted with $ZSTATUS=%YDB-E-JANSSONINVALIDJSON
ZSTATUS=T2+137^ydb1152,%YDB-W-ZYDECODEINCOMPL, Error encountered during ZYDECODE; operation may be incomplete,%YDB-E-JANSSONINVALIDJSON, Invalid JSON: unable to decode byte 0xa7 near '"' - in ydb_decode_s() call

## Test 2g: ZYDECODEINCOMPL and JANSSONINVALIDJSON errors issued when using ZYDECODE to decode a node containing `$C(0)` from a node previously encoded with ZYENCODE
# Run [x(1)=$c(0)]
# Run [zyencode y=x]
# Run [zydecode z=y]
# Expect '%YDB-W-ZYDECODEINCOMPL' to be emitted with $ZSTATUS=%YDB-E-JANSSONINVALIDJSON
ZSTATUS=T2+147^ydb1152,%YDB-W-ZYDECODEINCOMPL, Error encountered during ZYDECODE; operation may be incomplete,%YDB-E-JANSSONINVALIDJSON, Invalid JSON: \u0000 is not allowed without JSON_ALLOW_NUL near '"\u0000"' - in ydb_decode_s() call

## Test 2h: ZYDECODEINCOMPL and GVSUBOFLOW errors issued when using subscripts that meet or exceed key size (256 in this case)
# Run [set x($justify(1,256))=1]
# Run [zyencode y=x]
# Run [zyencode ^z=y]
# Expect '%YDB-W-ZYDECODEINCOMPL' to be emitted with $ZSTATUS=%YDB-E-GVSUBOFLOW
ZSTATUS=T2+158^ydb1152,%YDB-W-ZYDECODEINCOMPL, Error encountered during ZYDECODE; operation may be incomplete,%YDB-E-GVSUBOFLOW, Maximum combined length of subscripts exceeded,%YDB-I-GVIS, 		Global variable: 		Global variable: ^z("                                                                                                                                                                                                                                                               1")
# Run [set x($justify(1,64),$justify(1,64),$justify(1,64),$justify(1,64))=1]
# Run [zyencode y=x]
# Run [zyencode ^z=y]
# Expect '%YDB-W-ZYDECODEINCOMPL' to be emitted with $ZSTATUS=%YDB-E-GVSUBOFLOW
ZSTATUS=T2+166^ydb1152,%YDB-W-ZYDECODEINCOMPL, Error encountered during ZYDECODE; operation may be incomplete,%YDB-E-GVSUBOFLOW, Maximum combined length of subscripts exceeded,%YDB-I-GVIS, 		Global variable: 		Global variable: ^z("                                                               1","                                                               1","                                                               1","                                                               1")
# Run [set x($justify(1,257))=1]
# Run [zyencode y=x]
# Run [zyencode ^z=y]
# Expect '%YDB-W-ZYDECODEINCOMPL' to be emitted with $ZSTATUS=%YDB-E-GVSUBOFLOW
ZSTATUS=T2+174^ydb1152,%YDB-W-ZYDECODEINCOMPL, Error encountered during ZYDECODE; operation may be incomplete,%YDB-E-PARAMINVALID, buf_addr is too small for at least 1 key in JSON input parameter specified in ydb_decode_s() call
# Run [set x($justify(1,65),$justify(1,64),$justify(1,64),$justify(1,64))=1]
# Run [zyencode y=x]
# Run [zyencode ^z=y]
# Expect '%YDB-W-ZYDECODEINCOMPL' to be emitted with $ZSTATUS=%YDB-E-GVSUBOFLOW
ZSTATUS=T2+182^ydb1152,%YDB-W-ZYDECODEINCOMPL, Error encountered during ZYDECODE; operation may be incomplete,%YDB-E-GVSUBOFLOW, Maximum combined length of subscripts exceeded,%YDB-I-GVIS, 		Global variable: 		Global variable: ^z("                                                                1","                                                               1","                                                               1","                                                               1")

### Test 3: ZYENCODE properly handles input trees containing ~1MiB of data (YDB max string length)
### See also the discussion at: https://gitlab.com/YottaDB/DB/YDB/-/merge_requests/1767#note_2854162278
## Test 3a: ZYENCODE properly handles input trees containing exactly 1MiB (1048576 bytes) of data
##TEST_AWK# Run the \[populateTree\] label to generate a tree with 1048576 bytes of data in the \["[\^]*T3aI"\] variable
# Set a GVN to update $REFERENCE and store the last GVN referenced by ZYENCODE.
##TEST_AWK# Run \[zyencode [\^]*T3aO.*=[\^]*T3aI.*\] to encode the generated tree into JSON format in the [\^]*T3aI variable
# Store the value of $REFERENCE
##TEST_AWK# Confirm \$REFERENCE \(the naked indicator\) is correctly set to the [\^T3aO]*.* variable:
##TEST_AWKPASS: \$REFERENCE=[\^T3aO]*.*
# Log encoded JSON to file [T3a.json]
# Confirm the root node reports the correct number of output nodes. Expect 1:
PASS : Expected 1 output node(s). Got 1 output node(s).
# Confirm the JSON output is of the correct size.  Expect 1048576:
PASS : Expected JSON output of size 1048576. Got JSON output of size 1048576.

## Test 3b: ZYENCODE properly handles input trees containing exactly 1MiB-1 (1048575 bytes) of data
##TEST_AWK# Run the \[populateTree\] label to generate a tree with 1048575 bytes of data in the \["[\^]*T3bI"\] variable
# Set a GVN to update $REFERENCE and store the last GVN referenced by ZYENCODE.
##TEST_AWK# Run \[zyencode [\^]*T3bO.*=[\^]*T3bI.*\] to encode the generated tree into JSON format in the [\^]*T3bI variable
# Store the value of $REFERENCE
##TEST_AWK# Confirm \$REFERENCE \(the naked indicator\) is correctly set to the [\^T3bO]*.* variable:
##TEST_AWKPASS: \$REFERENCE=[\^T3bO]*.*
# Log encoded JSON to file [T3b.json]
# Confirm the root node reports the correct number of output nodes. Expect 1:
PASS : Expected 1 output node(s). Got 1 output node(s).
# Confirm the JSON output is of the correct size.  Expect 1048575:
PASS : Expected JSON output of size 1048575. Got JSON output of size 1048575.

## Test 3c: ZYENCODE properly handles input trees containing exactly 1MiB-2 (1048574 bytes) of data
##TEST_AWK# Run the \[populateTree\] label to generate a tree with 1048574 bytes of data in the \["[\^]*T3cI"\] variable
# Set a GVN to update $REFERENCE and store the last GVN referenced by ZYENCODE.
##TEST_AWK# Run \[zyencode [\^]*T3cO.*=[\^]*T3cI.*\] to encode the generated tree into JSON format in the [\^]*T3cI variable
# Store the value of $REFERENCE
##TEST_AWK# Confirm \$REFERENCE \(the naked indicator\) is correctly set to the [\^T3cO]*.* variable:
##TEST_AWKPASS: \$REFERENCE=[\^T3cO]*.*
# Log encoded JSON to file [T3c.json]
# Confirm the root node reports the correct number of output nodes. Expect 1:
PASS : Expected 1 output node(s). Got 1 output node(s).
# Confirm the JSON output is of the correct size.  Expect 1048574:
PASS : Expected JSON output of size 1048574. Got JSON output of size 1048574.

## Test 3d: ZYENCODE properly handles input trees containing exactly 1MiB+1 (1048577 bytes) of data
##TEST_AWK# Run the \[populateTree\] label to generate a tree with 1048577 bytes of data in the \["[\^]*T3dI"\] variable
# Set a GVN to update $REFERENCE and store the last GVN referenced by ZYENCODE.
##TEST_AWK# Run \[zyencode [\^]*T3dO.*=[\^]*T3dI.*\] to encode the generated tree into JSON format in the [\^]*T3dI variable
# Store the value of $REFERENCE
##TEST_AWK# Confirm \$REFERENCE \(the naked indicator\) is correctly set to the [\^T3dO]*.* variable:
##TEST_AWKPASS: \$REFERENCE=[\^T3dO]*.*
# Log encoded JSON to file [T3d.json]
# Confirm the root node reports the correct number of output nodes. Expect 2:
PASS : Expected 2 output node(s). Got 2 output node(s).
# Confirm the JSON output is of the correct size.  Expect 1048577:
PASS : Expected JSON output of size 1048577. Got JSON output of size 1048577.

## Test 3e: ZYENCODE properly handles input trees containing exactly 1MiB+2 (1048578 bytes) of data
##TEST_AWK# Run the \[populateTree\] label to generate a tree with 1048578 bytes of data in the \["[\^]*T3eI"\] variable
# Set a GVN to update $REFERENCE and store the last GVN referenced by ZYENCODE.
##TEST_AWK# Run \[zyencode [\^]*T3eO.*=[\^]*T3eI.*\] to encode the generated tree into JSON format in the [\^]*T3eI variable
# Store the value of $REFERENCE
##TEST_AWK# Confirm \$REFERENCE \(the naked indicator\) is correctly set to the [\^T3O]*.* variable:
##TEST_AWKPASS: \$REFERENCE=[\^T3O]*.*
# Log encoded JSON to file [T3e.json]
# Confirm the root node reports the correct number of output nodes. Expect 2:
PASS : Expected 2 output node(s). Got 2 output node(s).
# Confirm the JSON output is of the correct size.  Expect 1048578:
PASS : Expected JSON output of size 1048578. Got JSON output of size 1048578.

### Test 4: ZYENCODE properly handles input trees containing random data sizes and arbitrary data types
### See also the discussion at: https://gitlab.com/YottaDB/DB/YDB/-/merge_requests/1767#note_2854162278
## Test 4a: ZYENCODE properly handles input trees containing random data sizes, up to 3MiB
##TEST_AWK# Run the \[populateTree\] label to generate a tree with [0-9]* bytes of data in the \["[\^]*T4aI"\] variable
# Set a GVN to update $REFERENCE and store the last GVN referenced by ZYENCODE.
##TEST_AWK# Run \[zyencode [\^]*T4aO.*=[\^]*T4aI.*\] to encode the generated tree into JSON format in the [\^]*T4aI variable
# Store the value of $REFERENCE
##TEST_AWK# Confirm \$REFERENCE \(the naked indicator\) is correctly set to the [\^T4aO]*.* variable:
##TEST_AWKPASS: \$REFERENCE=[\^Ta4O]*.*
# Log encoded JSON to file [T4a.json]
##TEST_AWK# Confirm the root node reports the correct number of output nodes. Expect [0-9]*:
##TEST_AWKPASS : Expected [0-9]* output node\(s\). Got [0-9]* output node\(s\).
##TEST_AWK# Confirm the JSON output is of the correct size.  Expect [0-9]*:
##TEST_AWKPASS : Expected JSON output of size [0-9]*. Got JSON output of size [0-9]*.
## Test 4b: ZYENCODE properly handles input trees containing random data sizes, < 1MiB
##TEST_AWK# Run the \[populateTree\] label to generate a tree with [0-9]* bytes of data in the \["[\^]*T4bI"\] variable
# Set a GVN to update $REFERENCE and store the last GVN referenced by ZYENCODE.
##TEST_AWK# Run \[zyencode [\^]*T4bO.*=[\^]*T4bI.*\] to encode the generated tree into JSON format in the [\^]*T4bI variable
# Store the value of $REFERENCE
##TEST_AWK# Confirm \$REFERENCE \(the naked indicator\) is correctly set to the [\^TbaO]*.* variable:
##TEST_AWKPASS: \$REFERENCE=[\^Tb4O]*.*
# Log encoded JSON to file [T4b.json]
##TEST_AWK# Confirm the root node reports the correct number of output nodes. Expect [0-9]*:
##TEST_AWKPASS : Expected [0-9]* output node\(s\). Got [0-9]* output node\(s\).
##TEST_AWK# Confirm the JSON output is of the correct size.  Expect [0-9]*:
##TEST_AWKPASS : Expected JSON output of size [0-9]*. Got JSON output of size [0-9]*.
## Test 4c: ZYENCODE properly handles input nodes containing arbitrary data types
# Run [set ^x=$C(0)_"null"]
# Run [zyencode z=^x]
# Expect no errors
# Run [set ^x=$C(0)_"true"]
# Run [zyencode z=^y]
# Expect no errors
# Run [set ^x=$C(0)_"false"]
# Run [zyencode z=^z]
# Expect no errors
# Run [set ^x(1)=1.1]
# Run [zyencode z=^z]
# Expect no errors

### Test 5: ZYDECODE properly handles input trees containing ~1MiB of data (YDB max string length)
### See also the discussion at: https://gitlab.com/YottaDB/DB/YDB/-/merge_requests/1767#note_2854162278
## Test 5a: ZYDECODE properly handles input trees containing exactly 1MiB (1048576 bytes) of data
##TEST_AWK# Run the \[populateTree\] label to generate a tree with 1048576 bytes of data in the \["[\^]*T5a"\] variable
##TEST_AWK# Run \[zyencode [\^]*T5aE.*=[\^]*T5aI.*] to encode the generated tree into JSON format in the [\^]*T5aE.* variable
# Run ZYDECODE to decode encoded input data
##TEST_AWK# Run \[zydecode [\^]*T5aO.*=[\^]*T5aE.*] to decode the encoded tree from JSON format into the [\^]*T5aO.* variable
##TEST_AWK# Confirm \$REFERENCE \(the naked indicator\) is correctly set to the [\^T5aOlst]*.* variable:
##TEST_AWKPASS: \$REFERENCE=[\^]*[T5aOlst]*.*
# Check each node of the decoded data against the input data.
# Expect the values to be identical.
PASS: ZYDECODE output mirrors input data

## Test 5b: ZYDECODE properly handles input trees containing exactly 1MiB-1 (1048575 bytes) of data
##TEST_AWK# Run the \[populateTree\] label to generate a tree with 1048575 bytes of data in the \["[\^]*T5b"\] variable
##TEST_AWK# Run \[zyencode [\^]*T5bE.*=[\^]*T5bI.*] to encode the generated tree into JSON format in the [\^]*T5bE.* variable
# Run ZYDECODE to decode encoded input data
##TEST_AWK# Run \[zydecode [\^]*T5bO.*=[\^]*T5bE.*] to decode the encoded tree from JSON format into the [\^]*T5bO.* variable
##TEST_AWK# Confirm \$REFERENCE \(the naked indicator\) is correctly set to the [\^]*[T5bOlast]*.* variable:
##TEST_AWKPASS: \$REFERENCE=[\^]*[T5bOlast]*.*
# Check each node of the decoded data against the input data.
# Expect the values to be identical.
PASS: ZYDECODE output mirrors input data

## Test 5c: ZYDECODE properly handles input trees containing exactly 1MiB-2 (1048574 bytes) of data
##TEST_AWK# Run the \[populateTree\] label to generate a tree with 1048574 bytes of data in the \["[\^]*T5c"\] variable
##TEST_AWK# Run \[zyencode [\^]*T5cE.*=[\^]*T5c.*] to encode the generated tree into JSON format in the [\^]*T5cE.* variable
# Run ZYDECODE to decode encoded input data
##TEST_AWK# Run \[zydecode [\^]*T5cO.*=[\^]*T5cE.*] to decode the encoded tree from JSON format into the [\^]*T5cO.* variable
##TEST_AWK# Confirm \$REFERENCE \(the naked indicator\) is correctly set to the [\^]*[T5cOlast]*.* variable:
##TEST_AWKPASS: \$REFERENCE=[\^]*[T5cOlast]*.*
# Check each node of the decoded data against the input data.
# Expect the values to be identical.
PASS: ZYDECODE output mirrors input data

## Test 5d: ZYDECODE properly handles input trees containing exactly 1MiB+1 (1048577 bytes) of data
##TEST_AWK# Run the \[populateTree\] label to generate a tree with 1048577 bytes of data in the \["[\^]*T5d"\] variable
##TEST_AWK# Run \[zyencode [\^]*T5dE.*=[\^]*T5d.*] to encode the generated tree into JSON format in the [\^]*T5dE.* variable
# Run ZYDECODE to decode encoded input data
##TEST_AWK# Run \[zydecode [\^]*T5dO.*=[\^]*T5dE.*] to decode the encoded tree from JSON format into the [\^]*T5dO.* variable
##TEST_AWK# Confirm \$REFERENCE \(the naked indicator\) is correctly set to the [\^]*[T5dOlast]*.* variable:
##TEST_AWKPASS: \$REFERENCE=[\^]*[T5dOlast]*.*
# Check each node of the decoded data against the input data.
# Expect the values to be identical.
PASS: ZYDECODE output mirrors input data

## Test 5e: ZYDECODE properly handles input trees containing exactly 1MiB+2 (1048578 bytes) of data
##TEST_AWK# Run the \[populateTree\] label to generate a tree with 1048578 bytes of data in the \["[\^]*T5e"\] variable
##TEST_AWK# Run \[zyencode [\^]*T5eE.*=[\^]*T5eI.*] to encode the generated tree into JSON format in the [\^]*T5eE.* variable
# Run ZYDECODE to decode encoded input data
##TEST_AWK# Run \[zydecode [\^]*T5eO.*=[\^]*T5eE.*] to decode the encoded tree from JSON format into the [\^]*T5eO.* variable
##TEST_AWK# Confirm \$REFERENCE \(the naked indicator\) is correctly set to the [\^]*[T5eOlast]*.* variable:
##TEST_AWKPASS: \$REFERENCE=[\^]*[T5eOlast]*.*
# Check each node of the decoded data against the input data.
# Expect the values to be identical.
PASS: ZYDECODE output mirrors input data

### Test 6: ZYDECODE properly handles input trees containing arbitrary types and random data sizes 
### See also the discussion at: https://gitlab.com/YottaDB/DB/YDB/-/merge_requests/1767#note_2854162278
## Test 6a: ZYDECODE properly handles input trees containing arbitrary (random) data sizes, up to 3MiB
##TEST_AWK# Run the \[populateTree\] label to generate a tree with [0-9]* bytes of data in the \["[\^]*T6a"\] variable
##TEST_AWK# Run \[zyencode [\^]*T6aE.*=[\^]*T6a.*] to encode the generated tree into JSON format in the [\^]*T6aE.* variable
# Run ZYDECODE to decode encoded input data
##TEST_AWK# Run \[zydecode [\^]*T6aO.*=[\^]*T6aE.*] to decode the encoded tree from JSON format into the [\^]*T6aO.* variable
##TEST_AWK# Confirm \$REFERENCE \(the naked indicator\) is correctly set to the [\^]*[T6aOlst]*.* variable:
##TEST_AWKPASS: \$REFERENCE=[\^]*[T6aOlst]*.*
# Check each node of the decoded data against the input data.
# Expect the values to be identical.
PASS: ZYDECODE output mirrors input data
## Test 6b: ZYDECODE properly handles input trees containing arbitrary (random) data sizes, < 1MiB
##TEST_AWK# Run the \[populateTree\] label to generate a tree with [0-9]* bytes of data in the \["[\^]*T6b"\] variable
##TEST_AWK# Run \[zyencode [\^]*T6bE.*=[\^]*T6b.*] to encode the generated tree into JSON format in the [\^]*T6bE.* variable
# Run ZYDECODE to decode encoded input data
##TEST_AWK# Run \[zydecode [\^]*T6bO.*=[\^]*T6bE.*] to decode the encoded tree from JSON format into the [\^]*T6bO.* variable
##TEST_AWK# Confirm \$REFERENCE \(the naked indicator\) is correctly set to the [\^]*[T6bOlast]*.* variable:
##TEST_AWKPASS: \$REFERENCE=[\^]*[T6bOlast].*
# Check each node of the decoded data against the input data.
# Expect the values to be identical.
PASS: ZYDECODE output mirrors input data

## Test 6c: ZYDECODE properly handles input trees containing arbitrary data types
# Run [set f=2,f(1)="{""array"": [1, 2, 3, 4, 5], ""key"": ""value"", ""null"": ",f(2)="null, ""string"": ""null"", ""real"": 3.1459, ""bool1"": true, ""bool2"": false}"
# Run [zydecode g=f]
# Expect decode to complete without error
# ZWRITE decoded output [zwrite g]
g("array",0)=1
g("array",1)=2
g("array",2)=3
g("array",3)=4
g("array",4)=5
g("bool1")=$C(0)_"true"
g("bool2")=$C(0)_"false"
g("key")="value"
g("null")=$C(0)_"null"
g("real")=3.1459
g("string")="null"

### Test 7: Data encoded with ZYENCODE can be decoded with ZYDECODE and re-encoded with ZYENCODE to produce the same result as the initial ZYENCODE call
##TEST_AWK# Run the \[populateTree\] label to generate a tree with [0-9]* bytes of data in the \["[\^]*T7.*"\] variable
##TEST_AWK# Run \[zyencode [\^]*T7E.*=[\^]*T7I.*] to encode the generated tree into JSON format in the [\^]*T7E.* variable
# Log generated JSON
# Log encoded JSON to file [T7a.json]
# Confirm encoding output is valid
##TEST_AWK# Confirm the root node reports the correct number of output nodes. Expect [0-9]*:
##TEST_AWKPASS : Expected [0-9]* output node\(s\). Got [0-9]* output node\(s\).
##TEST_AWK# Confirm the JSON output is of the correct size.  Expect [0-9]*:
##TEST_AWKPASS : Expected JSON output of size [0-9]*. Got JSON output of size [0-9]*.
##TEST_AWK# Run \[zydecode [\^]*T7O.*=[\^]*T7E.*] to decode the encoded tree from JSON format into the [\^]*T7O.* variable
# Check each node of the decoded data against the input data.
# Expect the values to be identical.
PASS: ZYDECODE output mirrors input data
##TEST_AWK# Log [\^]*T7O to node-T7b-.*.out file
##TEST_AWK# Run \[zyencode [\^]*T7S.*=[\^]*T7O.*] to encode the generated tree into JSON format in the [\^]*T7S.* variable
##TEST_AWK# Log [\^]*T7S to node-T7c-.*.out file
# Log generated JSON
# Log encoded JSON to file [T7b.json]
# Confirm encoding output is valid
##TEST_AWK# Confirm the root node reports the correct number of output nodes. Expect [0-9]*:
##TEST_AWKPASS : Expected [0-9]* output node\(s\). Got [0-9]* output node\(s\).
##TEST_AWK# Confirm the JSON output is of the correct size.  Expect [0-9]*:
##TEST_AWKPASS : Expected JSON output of size [0-9]*. Got JSON output of size [0-9]*.

### Test 8: No ZYDECODEWRONGCNT for trees with many subscripts at the same level
### For details, see discussion at https://gitlab.com/YottaDB/DB/YDB/-/merge_requests/1767#note_2844227740
## Test 8a: Using global variables
# Set a random length subscript, up to (10)
# Set a random length value, up to (16384)
# Set 10000 global variable nodes to the random value
# Use ZYENCODE to encode the nodes
# Use ZYDECODE to decode the nodes, expect no ZYDECODEWRONGCNT error
## Test 8b: Using local variables# Set a random length subscript, up to (10)
# Set a random length value, up to (16384)
# Set 10000 local variable nodes to the random value
# Use ZYENCODE to encode the nodes
# Use ZYDECODE to decode the nodes, expect no ZYDECODEWRONGCNT error

### Test 9: Confirm no errors for subscripts or values less than the string length of 4294967295
## Test 9a: Using global variables
# Set a random length subscript, up to the maximum (64)
# Set a random length value, up to the maximum (16384)
# Set 10000 global variable nodes to the random value
# Use ZYENCODE to encode the nodes, expect no errors
# Use ZYDECODE to decode the nodes, expect no ZYDECODEWRONGCNT error
## Test 9b: Using local variables
# Set a random length subscript, up to the maximum length (64)
# Set a random length value, up to the maximum (16384)
# Set 10000 local variable nodes to the random value
# Use ZYENCODE to encode the nodes, expect no errors
# Use ZYDECODE to decode the nodes, expect no ZYDECODEWRONGCNT error

### Test 10: ZYENCODE behavior with null subscripts
## Test 10a: No assert failure for ZYENCODE with null subscript and string node value
## See: https://gitlab.com/YottaDB/DB/YDB/-/merge_requests/1767#note_2854172324
## Test 10b: No hang for ZYENCODE with null subscript and integer node value
## See: https://gitlab.com/YottaDB/DB/YDB/-/merge_requests/1767#note_2854172331

### Test 11: ZYDECODE can nest with triggers
### See: https://gitlab.com/YottaDB/DB/YDB/-/merge_requests/1767#note_2854196286
## Test 11a: Trigger combination 1, expect no ASSERT failures
# Set triggers
No matching triggers found for deletion
Added SET trigger on ^x named x#1
# Set nodes in LVN
# Run ZYENCODE to encode nodes into ^x
ZSTATUS=T11c+3^ydb1152,%YDB-W-ZYENCODEINCOMPL, Error encountered during ZYENCODE; operation may be incomplete,%YDB-E-BADZYENZYDENEST, Unsupported nesting of ZYENCODE or ZYDECODE command
ZSTATUS=T11c+4^ydb1152,%YDB-E-ZYDECODEWRONGCNT, Error encountered during ZYDECODE; JSON chunk count in root of source variable must be a positive integer
ZSTATUS=T11b+8^ydb1152,%YDB-E-TRIGTLVLCHNG, Detected a net transaction level ($TLEVEL) change during trigger x#1#. Transaction level must be the same at exit as when the trigger started
# Run MERGE of ^x into ^y
# Kill ^x
# Run ZYDECODE of ^y into ^x
# Expect no ASSERT failure
## Test 17b: Trigger combination 2, expect no ASSERT failures
# Set triggers
All existing triggers (count = 1) deleted
Added SET trigger on ^x named x#1
# Set nodes in LVN
# Run ZYENCODE to encode nodes into ^x
ZSTATUS=T11d+2^ydb1152,%YDB-W-ZYENCODEINCOMPL, Error encountered during ZYENCODE; operation may be incomplete,%YDB-E-BADZYENZYDENEST, Unsupported nesting of ZYENCODE or ZYDECODE command
ZSTATUS=T11d+3^ydb1152,%YDB-E-ZYDECODEWRONGCNT, Error encountered during ZYDECODE; JSON chunk count in root of source variable must be a positive integer
ZSTATUS=T11b+8^ydb1152,%YDB-E-TRIGTLVLCHNG, Detected a net transaction level ($TLEVEL) change during trigger x#1#. Transaction level must be the same at exit as when the trigger started
# Run MERGE of ^x into ^y
# Kill ^x
# Run ZYDECODE of ^y into ^x
# Expect no ASSERT failure
ZSTATUS=T11b+15^ydb1152,%YDB-E-ZYDECODEWRONGCNT, Error encountered during ZYDECODE; JSON chunk count in root of source variable must be a positive integer

### Test 12: CTRL-C during long-running ZYENCODE does not cause GTMASSERT2 failure on subsequent command
PASS: Long-running ZYENCODE completed without GTMASSERT2 failure

### Test 13: Test that running ZYENCODE and ZYDECODE with 31 1MiB subscripts in a local variable does not cause a heap-buffer-overflow, or ZYDECODEINCOMPL or PARAMINVALID errors
### See also: https://gitlab.com/YottaDB/DB/YDB/-/merge_requests/1767#note_2843975764.
# Run [T13a^ydb1152] routine to pass 31 1MiB subscripts to ZYENCODE and ZYDECODE
# Confirm no PARAMINVALID and ZYDECODEINCOMPL errors were generated
PASS: [T13a^ydb1152] did not emit ZYDECODEINCOMPL and/or PARAMINVALID
# Run [T13b^ydb1152] routine to pass a single 1MiB subscript to ZYENCODE and ZYDECODE
# Confirm PARAMINVALID and ZYDECODEINCOMPL errors were generated
----------
Error PARAMINVALID seen in T13b.out as expected:
%YDB-E-PARAMINVALID, buf_addr is too small for at least 1 key in JSON input parameter specified in ydb_decode_s() call
----------
----------
Error ZYDECODEINCOMPL seen in T13b.out as expected:
%YDB-W-ZYDECODEINCOMPL, Error encountered during ZYDECODE; operation may be incomplete
----------

### Test 14: Test that sending MUPIP INTRPT to ZYENCODE and ZYDECODE does not produce any of the following errors: ZYENCODEINCOMPL, ZYDECODEINCOMPL, TEST-E-FAIL
### See also:
###   1. https://gitlab.com/YottaDB/DB/YDB/-/merge_requests/1767#note_2850600795
###   2. https://gitlab.com/YottaDB/DB/YDB/-/merge_requests/1767#note_2851162582
# Run [T14^ydb1152] routine in the background
# Confirm no ZYENCODEINCOMPL, ZYDECODEINCOMPL, or TEST-E-FAIL errors were generated
PASS: [T14^ydb1152] did not emit ZYDECODEINCOMPL and/or PARAMINVALID

### Test 15: No REC2BIG error is issued when values at default database record size
### are encoded and decoded when the database is created with default values.
### See also: https://gitlab.com/YottaDB/DB/YDB/-/merge_requests/1767#note_2850600795.
# Create a new database with default settings
# Run [T15^ydb1152] routine
# Confirm no REC2BIG errors were generated
PASS: [T15^ydb1152] did not emit REC2BIG

### Test 16: No assert failure indirection is used to encode value at the default database record size
### For details: https://gitlab.com/YottaDB/DB/YDB/-/merge_requests/1767#note_2851331998
# Create a new database with default settings
# Run [T16^ydb1152] routine
# Confirm no assert failure occurred and a ZYENCODESRCUNDEF error was issued
PASS: [T16^ydb1152] did not cause an assert failure
----------
Error ZYENCODESRCUNDEF seen in T16.out as expected:
%YDB-E-ZYENCODESRCUNDEF, Error encountered during ZYENCODE; source variable must not be undefined
----------

### Test 17: Test ZYENCODE within TSTART/TCOMMIT with restarts does not produce ZYDECODEINCOMPL or ZYENCODEINCOMPL errors
### See also: https://gitlab.com/YottaDB/DB/YDB/-/merge_requests/1767#note_2853870076
# Run [T17^ydb1152] routine
# Confirm no ZYENCODEINCOMPL, ZYDECODEINCOMPL, or other errors were generated
PASS: [T17^ydb1152] did not emit any errors.

### Test 18: GVUNDEF for KILL during ZYENCODE loop shows global variable name
PASS: GVUNDEF for KILL during ZYENCODE loop shows global variable name

### Test 19: ZYDECODE works with triggers (see test cases at https://gitlab.com/YottaDB/DB/YDB/-/merge_requests/1767#note_2956960973)
# Run [T19^ydb1152] routine
Added SET trigger on ^dst named dst#1
# Test sr_port/op_zydecode_arg.c:82ZSTATUS=T19a+2^ydb1152,%YDB-W-ZYDECODEINCOMPL, Error encountered during ZYDECODE; operation may be incomplete,%YDB-E-BADZYENZYDENEST, Unsupported nesting of ZYENCODE or ZYDECODE command
ZSTATUS=T19+5^ydb1152,%YDB-W-ZYDECODEINCOMPL, Error encountered during ZYDECODE; operation may be incomplete,%YDB-E-TRIGTLVLCHNG, Detected a net transaction level ($TLEVEL) change during trigger . Transaction level must be the same at exit as when the trigger started
Added SET trigger on ^dst2 named dst2#1
# Test sr_port/op_zydecode_arg.c:120ZSTATUS=T19b+3^ydb1152,%YDB-W-ZYDECODEINCOMPL, Error encountered during ZYDECODE; operation may be incomplete,%YDB-E-BADZYENZYDENEST, Unsupported nesting of ZYENCODE or ZYDECODE command
ZSTATUS=T19+8^ydb1152,%YDB-W-ZYDECODEINCOMPL, Error encountered during ZYDECODE; operation may be incomplete,%YDB-E-TRIGTLVLCHNG, Detected a net transaction level ($TLEVEL) change during trigger . Transaction level must be the same at exit as when the trigger started

### Test 20: ZYDECODE and ZYENCODE work with JSON arrays with more than 31 elements without issue
# Run [T20^ydb1152] routine
## Test 20a: Decoding a JSON array with more than 31 elements works without issue
# Run [set f=2,f(1)="{""array"": [1, 2, 3, 4, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], ""key"": ""value"", ""null"": "
# Run [set f(2)="null, ""string"": ""null""}"]
# Run [zydecode g=f]
# Expect no error messsages to occur
## Test 20b: Encoding the M array created by 2i correctly creates a JSON array without issue
# Run [zyencode f=g("array")]
# Expect no error messages to occur, and a proper JSON array to be encoded
[1, 2, 3, 4, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]

### Test 21: ZYENCODE encodes into JSON arrays when all the conditions are met, otherwise it encodes into JSON objects
# Run [T21^ydb1152] routine
## Test 21a: Encoding an M array that does not match the condition for a JSON array, it starts with a subscript other than 0
# Run [set marray(0)="zero",marray(1)="one",marray(2)="two",marray(3)="three",marray(4)="four",marray(5)="five",marray(6)="six"]
# Run [set marray(7)="seven",marray(8)="eight",marray(9)="nine",marray(10)="ten",marray(11)="eleven",marray(12)="twelve"]
# Run [set marray(-1)="negative one"]
# Run [zyencode json=marray]
{"-1": "negative one", "0": "zero", "1": "one", "2": "two", "3": "three", "4": "four", "5": "five", "6": "six", "7": "seven", "8": "eight", "9": "nine", "10": "ten", "11": "eleven", "12": "twelve"}
# Run [kill marray(-1)]
## Test 21b: Encoding an M array that does not match the condition for a JSON array, it doesn't strictly increment by an integer for each element
# Run [kill marray(5)]
# Run [zyencode json=marray]
{"0": "zero", "1": "one", "2": "two", "3": "three", "4": "four", "6": "six", "7": "seven", "8": "eight", "9": "nine", "10": "ten", "11": "eleven", "12": "twelve"}
# Run [set marray(5)="five"]
## Test 21c: Encoding an M array that does not match the condition for a JSON array, it has a subscript at the same level which is not an integer
# Run [set marray("key")="value"]
# Run [zyencode json=marray]
{"0": "zero", "1": "one", "2": "two", "3": "three", "4": "four", "5": "five", "6": "six", "7": "seven", "8": "eight", "9": "nine", "10": "ten", "11": "eleven", "12": "twelve", "key": "value"}
# Run [kill marray("key")]
## Test 21d: Encoding an M array that does not match the condition for a JSON array, its parent node contains data
# Run [set marray="numbers"]
# Run [zyencode json=marray]
{"": "numbers", "0": "zero", "1": "one", "2": "two", "3": "three", "4": "four", "5": "five", "6": "six", "7": "seven", "8": "eight", "9": "nine", "10": "ten", "11": "eleven", "12": "twelve"}

# Check all ZYENCODE JSON output files for valid JSON
PASS: T3a.json contains valid JSON
PASS: T3b.json contains valid JSON
PASS: T3c.json contains valid JSON
PASS: T3d.json contains valid JSON
PASS: T3e.json contains valid JSON
PASS: T4a.json contains valid JSON
PASS: T4b.json contains valid JSON
PASS: T7a.json contains valid JSON
PASS: T7b.json contains valid JSON

