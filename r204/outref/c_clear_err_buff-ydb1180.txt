# Test to make sure that ECODE race condition problem does not occur.
# There was a bug where after a call to ydb_ci[p]_t the dollar_ecode buffer
# would not be cleared. This would result in the program remaining in an error
# state after the erroring thread had closed. The solution is to empty the
# dollar_ecode buffer at the start and end of every ydb_ci[p]_t call.
# First, test a will test for this bug by running a mumps program with a
# division by 0 error in C code with ydb_ci_t.
# Then, it will run code that only produces a TPTIMEOUT error if not already in an error state.
# This is easy as a TPTIMEOUT is deferred until $ECODE is cleared.
# If ydb_ci_t reset the dollar_ecode then a TPTIMEOUT error will be recorded.
# So, as this bug has been fixed, we expect to get a TPTIMEOUT error.
# Afterwards, test b will be the same test but using ydb_cip_t instead of ydb_ci_t.
# More information about where this test came form: https://gitlab.com/YottaDB/DB/YDB/-/issues/1180#note_2887736924
# Also includes tests c and d to make sure that $ECODE is reset in [ydb|gtm]_cip and [ydb|gtm]_ci.
# In these tests, an error is invoked in one script and the value of $ECODE is checked in the next one.
# This functionality has also been changed as a result of #1180 to be consistent with the
# ydb_ci[p]_t functionality.
# Relevant Gitlab discussion: https://gitlab.com/YottaDB/DB/YDB/-/issues/1180#note_3025071433

# Building call in table
# with ydb1180ma and ydb1180mb to cause errors
# and ydb1180WE to write out the value of $ECODE.

# Starting test a with ydb_ci_t ydb1180a.c.
# Starting compilation.
# Starting linking.
# Running the compiled ydb1180a.c program.
# As stated above, the program will time out if it finds it is not in an error state.
# So first we expect a zero division error from ydb_ci_t.
# Then, if the dollar_ecode is properly cleared, we should also get a TPTIMEOUT error
150373210,+16^ydb1180ma,%YDB-E-DIVZERO, Attempt to divide by zero
ydb_tp_st() : status = -150377322 : 150377322,(SimpleThreadAPI),%YDB-E-TPTIMEOUT, Transaction timeout

# Starting test b with ydb_cip_t ydb1180b.c.
# Starting compilation.
# Starting linking.
# Running the compiled ydb1180b.c program.
# As stated above, the program will time out if it finds it is not in an error state.
# So first we expect a zero division error from ydb_cip_t.
# Then, if the dollar_ecode is properly cleared, we should also get a TPTIMEOUT error
150373210,+16^ydb1180mb,%YDB-E-DIVZERO, Attempt to divide by zero
ydb_tp_st() : status = -150377322 : 150377322,(SimpleThreadAPI),%YDB-E-TPTIMEOUT, Transaction timeout

# Starting test c with ydb_cip and gtm_cip ydb1180c.c.
# Starting compilation.
# Starting linking.
# Running the compiled ydb1180c.c program.
# Previously, the error would have persisted so that when we print $ECODE
# there would have been an error left from the ydb1180ma call.
# Now that ecode does not persist, we expect a line that says
# "$ECODE is:" followed immediately by a newline
# indicating that $ECODE was correctly cleared.
# This result will happen twice, first for the ydb then the gtm version of the API.
$ECODE is:
$ECODE is:

# Starting test d with ydb_ci and gtm_ci ydb1180d.c.
# Starting compilation.
# Starting linking.
# Running the compiled ydb1180d.c program.
# Previously, the error would have persisted so that when we print $ECODE
# there would have been an error left from the ydb1180ma call.
# Now that ecode does not persist, we expect a line that says
# "$ECODE is:" followed immediately by a newline
# indicating that $ECODE was correctly cleared.
# This result will happen twice, first for the ydb then the gtm version of the API.
$ECODE is:
$ECODE is:
