#!/usr/bin/expect -f
#################################################################
#								#
# Copyright (c) 2018 YottaDB LLC. and/or its subsidiaries.	#
# All rights reserved.						#
#								#
#	This source code contains the intellectual property	#
#	of its copyright holder(s), and is made available	#
#	under a license.  If you do not know the terms of	#
#	the license, please stop and do not read further.	#
#								#
#################################################################
#
#
# This Expect script was generated by autoexpect on Fri Mar  6 17:44:05 2009
# Expect and autoexpect were both written by Don Libes, NIST.
#
# Note that autoexpect does not guarantee a working script.  It
# necessarily has to guess about certain things.  Two reasons a script
# might fail are:
#
# 1) timing - A surprising number of programs (rn, ksh, zsh, telnet,
# etc.) and devices discard or ignore keystrokes that arrive "too
# quickly" after prompts.  If you find your new script hanging up at
# one spot, try adding a short sleep just before the previous send.
# Setting "force_conservative" to 1 (see below) makes Expect do this
# automatically - pausing briefly before sending each character.  This
# pacifies every program I know of.  The -c flag makes the script do
# this in the first place.  The -C flag allows you to define a
# character to toggle this mode off and on.

set force_conservative 0  ;# set to 1 to force conservative mode even if
			  ;# script wasn't run conservatively originally
if {$force_conservative} {
	set send_slow {1 .1}
	proc send {ignore arg} {
		sleep .1
		exp_send -s -- $arg
	}
}

#
# 2) differing output - Some programs produce different output each time
# they run.  The "date" command is an obvious example.  Another is
# ftp, if it produces throughput statistics at the end of a file
# transfer.  If this causes a problem, delete these patterns or replace
# them with wildcards.  An alternative is to use the -p flag (for
# "prompt") which makes Expect only look for the last line of output
# (i.e., the prompt).  The -P flag allows you to define a character to
# toggle this mode off and on.
#
# Read the man page for more info.
#
# -Don


set host [lindex $argv 0]
set gtm_ver [lindex $argv 1]
set gtm_tst [lindex $argv 2]
set subtest [lindex $argv 3]
set remotepath [lindex $argv 4]
#set gtmroutines [lindex $argv 3]


set timeout 360
# silence the MOTD and other login banners
# note you might have to edit the server's SSH config
# and possible even PAM to turn off all banners
spawn ssh $host touch .hushlogin

spawn ssh $host
match_max 100000
expect "*"
set send_slow {1 .01}
set GTM_SHORT_SLEEP .5
set GTM_LONG_SLEEP 1.5

proc send_wait {arg} {
	send -s -- $arg
	expect -- $arg
	sleep 1.5
	}

# wait for remote shell to start
sleep 5

send -- "setenv tst $subtest\r"
send -- "setenv host $host\r"
expect -exact "setenv tst $subtest\r\r"
expect "*"
send -- "set prompt=\"\$host \$tst > \"\r"
expect -exact "set prompt=\"\$host \$tst > \"\r\r
$host $subtest > "
send -- "setenv test_gtm_gtcm GT.M\r"
expect -exact "setenv test_gtm_gtcm GT.M\r\r
$host $subtest > "
send -- "setenv gtmgbldir `pwd`/mumps\r"
expect -exact "setenv gtmgbldir `pwd`/mumps\r\r
$host $subtest > "
send -- "setenv gtm_ver $gtm_ver\r"
expect -exact "setenv gtm_ver $gtm_ver\r\r
$host $subtest > "
send -- "setenv gtm_exe \$gtm_ver/dbg\r"
expect -exact "setenv gtm_exe \$gtm_ver/dbg\r\r
$host $subtest > "
send -- "setenv gtm_dist \$gtm_exe\r"
expect -exact "setenv gtm_dist \$gtm_exe\r\r
$host $subtest > "
send -- "setenv gtm_obj \$gtm_exe/obj\r"
expect -exact "setenv gtm_obj \$gtm_exe/obj\r\r
$host $subtest > "
send -- "setenv gtm_tst $gtm_tst\r"
expect -exact "setenv gtm_tst $gtm_tst\r\r
$host $subtest > "
send -- "source $gtm_tst/com/set_specific.csh\r"
expect -exact "source $gtm_tst/com/set_specific.csh\r\r
$host $subtest > "
send -- "setenv GTM \"\$gtm_exe/mumps -direct\"\r"
expect -exact "setenv GTM \"\$gtm_exe/mumps -direct\"\r\r
$host $subtest > "
send -- "setenv DSE \"\$gtm_exe/dse\"\r"
expect -exact "setenv DSE \"\$gtm_exe/dse\"\r\r
$host $subtest > "
send -- "setenv gtmroutines \". \$gtm_ver/dbg \$gtm_ver/pct \$gtm_tst/\$tst/inref \$gtm_tst/com\"\r"
expect -exact "setenv gtmroutines \". \$gtm_ver/dbg \$gtm_ver/pct \$gtm_tst/\$tst/inref \$gtm_tst/com\"\r\r
$host $subtest > "
send -- "echo Beginning Job Interrupt and terminal testing"
expect -exact "echo Beginning Job Interrupt and terminal testing"
send -- "\r"
expect "*"
send -- "$gtm_tst/com/dbcreate.csh mumps"
expect -exact "$gtm_tst/com/dbcreate.csh mumps"
send -- "\r"
expect -exact "\r\r
Files Created in $remotepath:\r
Using: $gtm_ver/dbg/mumps -run GDE\r
mumps.gld\r
Using: $gtm_ver/dbg/mupip\r
mumps.dat\r"
expect "*"
send -- "echo Now call the expect script"
expect -exact "echo Now call the expect script"
send -- "\r"
expect "*"
send -- "\$gtm_exe/mumps -run d002636\r"
expect "for interrupt: "
sleep 15
send -- "end of wait for interrupt\r"
# send input in chunks with sleeps to allow the iterrupter to interrupt
# need -s to avoid overruning GTM input especially for direct mode or edit
expect "enter the alphabet: "
sleep $GTM_SHORT_SLEEP
send_wait "abcde"
send_wait "fghij"
send_wait "klmno"
send_wait "pqrst"
send_wait "uvwxyz\r"
expect "YDB>"
# split up commands to increase likelihood of interrupt during entry
set send_slow {1 .1}
sleep $GTM_SHORT_SLEEP
send -s -- "zshow "
sleep $GTM_LONG_SLEEP
send -s "\"S\"\r"
expect "YDB>"
sleep $GTM_LONG_SLEEP
send -s -- "zshow "
sleep $GTM_LONG_SLEEP
send -s -- "\"D\"\r"
expect "YDB>"
sleep $GTM_LONG_SLEEP
send -s -- "zcon"
sleep $GTM_LONG_SLEEP
send -s -- "tinue\r"
expect -- "Test Passed"
sleep 1

send -- "$gtm_tst/com/dbcheck.csh\r"
expect -exact "$gtm_tst/com/dbcheck.csh\r\r
$gtm_ver/dbg/mupip\r
$gtm_ver/dbg/mupip integ -REG *\r
No errors detected by integ.\r
$host $subtest > "
send -- "exit\r"
expect eof
sleep 5
spawn ssh $host rm .hushlogin
expect eof
