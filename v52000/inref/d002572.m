;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;								;
; Copyright 2007, 2013 Fidelity Information Services, Inc	;
;								;
; Copyright (c) 2019 YottaDB LLC and/or its subsidiaries.	;
; All rights reserved.						;
;								;
;	This source code contains the intellectual property	;
;	of its copyright holder(s), and is made available	;
;	under a license.  If you do not know the terms of	;
;	the license, please stop and do not read further.	;
;								;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
d002572	;
	; At a high level, this program tests that
	;	a) Code containing non-GT.M ISVs or functions or deviceparameters issue compile-time errors AND
	;	b) The same code does not issue run-time error if it is preceded by a command postconditional
	;		that causes this codepath not to be reached at runtime.
	; It tests this by generating M-programs containing such bad code and running them on the fly.
	;
	; For each test case below, this program tests that
	;          i) postconditional=FALSE means NO RUNTIME ERROR.
	;         ii) postconditional=TRUE  means RUNTIME ERROR.
	;
        ; This program tests cases WITH and WITHOUT INDIRECTION. The WITH INDIRECTION cases are tested in this program itself.
	; The non-INDIRECTION cases are tested in the generated M programs.
	;
	; The following scenarios are tested
	;         1) Invalid Functions (simple)             --> $ZU(x)                                    /* INVFCN error */
	;         2) Invalid Functions with nested parens   --> $ZU(abcd,$length($piece("()))",")",2)))   /* INVFCN error */
	;         3) Functions that trigger FNOTONSYS error --> $ZLKID(..) on Unix and $ZCONVERT(..) on VMS /* FNOTONSYS error */
	;         4) SET valid-isv that is not settable     --> $TEST                                     /* SVNOSET error */
	;         5) SET invalid isv                        --> $ZU                                       /* INVSVN error */
	;         6) NEW valid-isv that is not newable      --> $QUIT                                     /* SVNONEW error */
	;         7) NEW invalid isv                        --> $ZU                                       /* INVSVN error */
	;         8) OPEN/USE/CLOSE invalid deviceparmeters --> Test DEVPARINAP, DEVPARUNK, DEVPARVALREQ errors.
	;
	; Only the SET and NEW commands were tested for postconditionals with invalid ISV or functions.
	; There are a lot of commands that allow command postconditionals as well as argument postconditionals.
	; It is a very big task to test all those out. Only those testcases that were felt relevant to the actual
	; code changes are tested here. Specifically, Argument postconditionals are NOT tested here.
	;
	; Even if a runtime error is encountered in one testcase, we want to proceed executing the next testcase.
	; For this purpose, we use the "incrtrap^incrtrap" routine as $ZTRAP.
	;
	; The M-programs that are generated by this program are named test*.m in the test output directory.
	;    test0*.m tests those cases where the postconditional evaluates to FALSE.
	;    test1*.m tests those cases where the postconditional evaluates to TRUE.
	;
	set $ztrap="goto incrtrap^incrtrap"
	set unix=$zversion'["VMS"
	set x="-1"
	set prefix=$c(9)
	set lineseparator="------------------------------------------------------"
	set tablineseparator=prefix_lineseparator;
	set commentlineseparator=prefix_"; "_lineseparator;
	for i=0,1  do
	.	set j=0
	.	for str="""""","0","i" do
	.	.	set j=j+1
	.	.	set file1="test"_i_j
	.	.	set file=file1_".m"
	.	.	open file:new
	.	.	use file
	.	.	write file1_$c(9)_";",!
	.	.	write prefix_"set $ztrap=""goto incrtrap^incrtrap""",!
	.	.	do helper
	.	.	write prefix_"quit",!
	.	.	close file
	set pattern="test*.m"
	set file=$zsearch(pattern)
	for  quit:file=""  do
	.	write lineseparator,!
	.	if unix  set file=$piece(file,"/",$length(file,"/"))
	.	if 'unix set file=$piece(file,"]",2),file=$piece(file,";",1)
	.	write !," --> Running M program ["_file,"] ----",!!
	.	set file=$piece(file,".",1)
	.	set xstr="^"_file
	.	do @xstr
	.	set file=$zsearch(pattern)
	quit
helper	;
	new index
	write commentlineseparator,!
	new xstr,xstr1,xstr2
	set xstr1=prefix_"w ""i="",i,"":x="",x,!"
	;--------------------------------------------
	; Test SET and NEW commands
	; -------------------------------------------
	set xstr2("set",1)="x=$zu(10)"						; test invalid function
	set xstr2("set",2)="x=$ZU(abcd,$length($piece(""()))"","")"",2)))"	; test invalid functions with nested parens
	set xstr2("set",3)="x=$ZU(abcd,$length($piece(""()))"","")"",2))"	; test invalid functions with bad paren nesting
	set xstr2("set",4)="x="_$select(unix:"$zlkid(abcd)",1:"$zconvert(abcd)")	; test functions that are NOT valid on the current
										;	platform (issue FNOTONSYS error)
	set xstr2("set",5)="x=$zu"						; test invalid ISV
	set xstr2("set",6)="x($zu,1)=i"						; test invalid ISV within a subscript
	set xstr2("set",7)="x=$piece($zu,"","",3,4)"				; test invalid ISV within valid function
	set xstr2("set",8)="x=$zu,y=i"						; test invalid ISV with another set
	set xstr2("set",9)="(x,$TEST)=1"					; test valid ISV that is NOT settable
	set xstr2("set",10)="$ZY=1"						; test invalid ISV on setleft
	set xstr2("set",11)="$ZY=x"						; test invalid ISV setleft with variable on right
	set xstr2("set",12)="$ZY=x+1"						; test invalid ISV setleft with expr on right
	set xstr2("set",13)="(x,$ZY)=($piece($h,"","",2)*0)+15"			; test valid setleft followed by invalid setleft
	set xstr2("set",14)="($ZY,x)=($piece($h,"","",2)*0)+15"			; test invalid setleft followed by valid setleft
	set xstr2("set",15)="(x,$ZY,z)=($piece($h,"","",2)*0)+15"		; test valid+invalid+valid setleft sequence
	set xstr2("set",16)="$ZU(abcd,$length($piece(""()))"","")"",2))=x"	; test invalid function with nested paren as setleft
	set xstr2("set",17)="$ZU(abcd,$length($piece(""()))"","")"",2))=x"	; test invalid function with badparen as setleft
	set xstr2("new",1)="$zu"						; test NEW with invalid ISV
	set xstr2("new",2)="$QUIT"						; test NEW with ISV that is not NEWable
	for cmdstr="set","new" do
	.	set index=$order(xstr2(cmdstr,""))
	.	for  quit:index=""  do  set index=$order(xstr2(cmdstr,index))
	.	.	set xstr2=xstr2(cmdstr,index)
	.	.	set xstr=prefix_"set i="_i_",x=""error1"" "_cmdstr_":"_str_" "_xstr2_"  set x=""ok1"""
	.	.	do outpandindr
	.	.	quit:"set"'=cmdstr
	.	.	set xstr=prefix_"set i="_i_",x=""error2"" if "_str_" set "_xstr2_"  set x=""ok2"""
	.	.	do outpandindr
	;
	;----------------------------------------------------------
	; Test deviceparameters with OPEN, USE and CLOSE commands
	; ---------------------------------------------------------
	set devparm(1)="afoo"						; simple invalid deviceparameter
	set devparm(2)="(zzzzzz)"					; simple invalid deviceparameter within parentheses
	set devparm(3)="(exception"					; simple invalid deviceparameter without right paren
	set devparm(4)="(rewind:zzzzzz)"				; invalid deviceparameter in a parameter list
	set devparm(5)="(rewind:exception=""x"":zzzzzz)"		; invalid deviceparameter at end of list with ="literal"
	set devparm(6)="(rewind:zzzzzz:exception=""x"")"		; invalid deviceparameter in middle of list
	;
	set index=$order(devparm(""))
	for  quit:index=""  do  set index=$order(devparm(index))
	.	for cmdstr="open","use","close"  do
	.	.	set xstr=prefix_"set i="_i_",x=""error1"" "_cmdstr_":"_str_" ""t.t"":"_devparm(index)_"  set x=""ok1"""
	.	.	do outpandindr
	quit
	;
outpandindr	;
	write xstr,!
	write xstr1,!
	if (i=0)&(str="i")  do
	.	use $p
	.	write lineseparator,!
	.	;write xstr,!
	.	xecute xstr
	.	xecute xstr1
	.	use file
	quit
