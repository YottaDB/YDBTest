;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;								;
;	Copyright 2011, 2014 Fidelity Information Services, Inc	;
;								;
; Copyright (c) 2022 YottaDB LLC and/or its subsidiaries.	;
; All rights reserved.						;
;								;
;	This source code contains the intellectual property	;
;	of its copyright holder(s), and is made available	;
;	under a license.  If you do not know the terms of	;
;	the license, please stop and do not read further.	;
;								;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
multilinezgoto
	; this test uses jobs to run the individual test cases
	do ^echoline
	set ^tp=$random(2)
	do text^dollarztrigger("tfile^multilinezgoto","multiline.trg")
	do file^dollarztrigger("multiline.trg",1)
	do ^job("primed^multilinezgoto",1,"""""")
	do ^job("unprimed^multilinezgoto",1,"""""")
	do ^job("nonexistent^multilinezgoto",1,"""""")
	; cat the job output files
	zsystem "cat primed*.mj*"
	zsystem "cat unprimed*.mj*"
	zsystem "cat nonexistent*.mj*"
	do forced
	do levelchange
	quit

	;----------------------------------------------------------------
	; you can only zgoto into a trigger if it has been
	; loaded into the run time
	; 'primed' will direct the 'test()' label to execute
	; the target trigger prior to zgoto'ing to it. With
	; the target trigger loaded, the test can zgoto into
	; it
primed
	do ^echoline
	do test(1)
	do notfromtrig
	do ^echoline
	do ^echoline
	quit

	; continuing the comments from above, 'unprimed' will
	; attempt to zgoto into a trigger than has not been
	; loaded by the runtime
unprimed
	do test()
	do notfromtrig
	do ^echoline
	do ^echoline
	quit

	; test entering trigger code when not from a trigger
notfromtrig
	do ^echoline
	set $ETRAP="write $zstatus,! set $ecode="""""
	write "zgoto ^mline#3# from non-trigger land",!
	write "$ZLevel = ",$ZLevel,$char(9),"$ZTLevel = ",$ZTLevel,!
	set x="mline#3#" zgoto $zlevel:^@x
	do ^echoline
	quit

	; drive the test for attempting to zgoto'ing into a trigger
test(primed)
	set $ETRAP="write $zstatus,! set $ecode="""""
	set tp=^tp
	if tp tstart ()
	write !
	write:$data(primed) "This test case primes the zgoto pump",!
	write:'$data(primed) "This test case does not prime the zgoto pump",!
	do ^echoline
	set ^mline($i(i))=i
	if $data(primed) do
	.	do ^echoline
	.	ztrigger ^mline(i)
	do ^echoline
	zkill ^mline(i)
	do ^echoline
	if tp tcommit
	quit

	;----------------------------------------------------------------
	; test zgoto'ing to a non-existent trigger reference
nonexistent
	set tp=^tp
	if tp tstart ()
	ztrigger ^malign
	if tp tcommit
	do ^echoline
	do ^echoline
	quit

	;----------------------------------------------------------------
	; use zgoto to force the order of trigger chaining
	; we abuse the autogenerated namespace to force the
	; ordering from 4 to 1
forced
	do ^echoline
	write "Force chained trigger order",!
	ztrigger ^forced("inchains")
	do ^echoline
	write "Force chained trigger order in nested trigger",!
	ztrigger ^forced("nest and chain")
	do ^echoline
	quit

	;----------------------------------------------------------------
	; zgoto between trigger levels, unstacking triggers
levelchange
	do ^echoline
	write "zgoto between trigger levels to unstack triggers",!
	ztrigger ^levelchange("unstack")
	do ^echoline
	write "zgoto between trigger levels, restarting the nesting",!
	ztrigger ^levelchange("repeat")
	do ^echoline
	quit


	; print out the M stack horizontally in reverse order
flatstack
	new stack,p,top
	zshow "s":stack
	write $char(9),$ZLevel-1,":",$ZTLEvel
	set top=$order(stack("S",""),-1)
	for p=top:-1:2 write $char(9),stack("S",p)
	quit

tfile
	;; testing multiline zgotos
	;;----------------------------------------------------------------
	;; This trigger only fires with SET
	;; this trigger is paired with [un]primed^multilinezogto
	;; for testing zgoto'ing into a multiline trigger
	;+^mline(:) -command=S -xecute=<<
	;	write $ZTNAme,!
	;	write "start"
	;	do flatstack^multilinezgoto w !
	;	do label1
	;	write "done"
	;	do flatstack^multilinezgoto w !
	;	quit
	;
	;label1
	;	write "label1"
	;	do flatstack^multilinezgoto w !
	;	do label2
	;	write "no way to get here",!
	;	do label3
	;	write "label1"
	;	do flatstack^multilinezgoto w !
	;	quit
	;
	;; test zgoto to the same level with a full label
	;label2
	;	write "label2"
	;	do flatstack^multilinezgoto w !
	;	write ?7,$text(label2+4^mline#1#),!
	;	zgoto $zlevel:label1+5^@$ZTNAme
	;	write "label2, should not be here",!
	;	quit
	;
	;; test zgoto unstacking two levels and a full label
	;label3
	;	write "label3"
	;	do flatstack^multilinezgoto w !
	;	zprint label3+4^mline#1#
	;	zgoto $zlevel-2:label1+6^@$ZTNAme
	;	write "label3, should not be here",!
	;	quit
	;>>
	;
	;; This trigger only fires with ZKILL
	;; this trigger is paired with [un]primed^multilinezogto
	;; for testing zgoto'ing into a multiline trigger
	;+^mline(:) -command=ZK -xecute=<<
	;	write $increment(once),?4,$ZTNAme,!
	;	if once>1 set x="mline#3#" zgoto $zlevel:^@x
	;	do label1
	;	do label2
	;	do label3
	;	quit
	;
	;label1
	;	do flatstack^multilinezgoto w !
	;	write ?7,$text(label1+3^@$ZTNAme),!
	;	zgoto -1
	;	write "label1, should not be here",!
	;	quit
	;label2
	;	do flatstack^multilinezgoto w !
	;	write ?7,$text(@$piece($zpos,"+",1)+3^@$ZTNAme),!
	;	zgoto $zlevel-1
	;	write "label1, should not be here",!
	;	quit
	;label3
	;	do flatstack^multilinezgoto w !
	;	set label=$piece($zpos,"+",1)
	;	set rtn=$piece($zpos,"^",2)
	;	set line=2+$piece($piece($zpos,"+",2),"^",1)
	;	ZPrint @label+line^@rtn
	;	zgoto $zlevel:^@$ZTNAme
	;	write "label2, should not be here",!
	;	quit
	;>>
	;
	;; This trigger only fires with ZTRIGGER
	;; this trigger is paired with [un]primed^multilinezogto
	;; as the destination of the ZGOTOs
	;+^mline(:) -command=ZTR -xecute=<<
	;	write $increment(once),?4,$ZTNAme," expects mline#3#",!
	;	write ?4,"ztriggerop is ",$ZTRI," and expects ZTR",!
	;	write "$ZLevel = ",$ZLevel,$char(9),"$ZTLevel = ",$ZTLevel,!
	;	quit
	;>>
	;
	;;----------------------------------------------------------------
	;; test zgoto'ing a non-existent trigger reference
	;+^malign -command=ZTR -xecute=<<
	;	set $ETRAP="do traphandler"
	;	write $i(once),?4,$ZTNAme," zgoto nonexistent mline#4#",!
	;	set x="mline#4#" zgoto $zlevel:^@x
	;	quit
	;
	;	; expect the ZLINKFILE error from the nonexistent trigger zgoto
	;traphandler
	;	set $ecode=""
	;	if $zstatus'["ZLINKFILE" write "unexpected",! zshow "s"
	;	write $ztrap,!
	;	quit
	;>>
	;
	;;----------------------------------------------------------------
	;; forced order for chained triggers
	;; the following ^forced triggers are identical except for one line
	;; hardcodes the trigger name.
	;; increment $ztslate until the 4th trigger and then zgoto to each
	;; trigger by name decrementing the value of $ztslate as we go
	;+^forced("inchains") -command=ZTR -xecute=<<
	;	set x=$ztslate,$ztslate=$increment(x)
	;	write x,?4,"I am ",$ZTNAme,!
	;	if x<4 quit
	;	set rtn="forced#"_$ztslate_"#"
	;	zgoto $zlevel:main^@rtn
	;	write "Should not get here",!
	;	quit
	;
	;main
	;	write "I am ",$ZTNAme," this code is main^forced#1#",!
	;	write "$ZLevel = ",$ZLevel,$char(9)
	;	write "ZTLevel = ",$ZTLevel,!
	;	if $ztslate=1 quit
	;	set x=$ztslate,$ztslate=$increment(x,-1)
	;	set rtn="forced#"_$ztslate_"#"
	;	zgoto $zlevel:main^@rtn
	;	write "Should not get here",!
	;	quit
	;>>
	;+^forced("inchains") -command=ZTR -xecute=<<
	;	set x=$ztslate,$ztslate=$increment(x)
	;	write x,?4,"I am ",$ZTNAme,!
	;	if x<4 quit
	;	set rtn="forced#"_$ztslate_"#"
	;	zgoto $zlevel:main^@rtn
	;	write "Should not get here",!
	;	quit
	;
	;main
	;	write "I am ",$ZTNAme," this code is main^forced#2#",!
	;	write "$ZLevel = ",$ZLevel,$char(9)
	;	write "ZTLevel = ",$ZTLevel,!
	;	if $ztslate=1 quit
	;	set x=$ztslate,$ztslate=$increment(x,-1)
	;	set rtn="forced#"_$ztslate_"#"
	;	zgoto $zlevel:main^@rtn
	;	write "Should not get here",!
	;	quit
	;>>
	;+^forced("inchains") -command=ZTR -xecute=<<
	;	set x=$ztslate,$ztslate=$increment(x)
	;	write x,?4,"I am ",$ZTNAme,!
	;	if x<4 quit
	;	set rtn="forced#"_$ztslate_"#"
	;	zgoto $zlevel:main^@rtn
	;	write "Should not get here",!
	;	quit
	;
	;main
	;	write "I am ",$ZTNAme," this code is main^forced#3#",!
	;	write "$ZLevel = ",$ZLevel,$char(9)
	;	write "ZTLevel = ",$ZTLevel,!
	;	if $ztslate=1 quit
	;	set x=$ztslate,$ztslate=$increment(x,-1)
	;	set rtn="forced#"_$ztslate_"#"
	;	zgoto $zlevel:main^@rtn
	;	write "Should not get here",!
	;	quit
	;>>
	;+^forced("inchains") -command=ZTR -xecute=<<
	;	set x=$ztslate,$ztslate=$increment(x)
	;	write x,?4,"I am ",$ZTNAme,!
	;	if x<4 quit
	;	set rtn="forced#"_$ztslate_"#"
	;	zgoto $zlevel:main^@rtn
	;	write "Should not get here",!
	;	quit
	;
	;main
	;	write "I am ",$ZTNAme," this code is main^forced#4#",!
	;	write "$ZLevel = ",$ZLevel,$char(9)
	;	write "ZTLevel = ",$ZTLevel,!
	;	if $ztslate=1 quit
	;	set x=$ztslate,$ztslate=$increment(x,-1)
	;	set rtn="forced#"_$ztslate_"#"
	;	zgoto $zlevel:main^@rtn
	;	write "Should not get here",!
	;	quit
	;>>
	;; nest and then do the forced trigger ordering
	;+^forced("nest and chain") -command=ZTR -xecute=<<
	;	write ?4,"I am ",$ZTNAme,$char(9)
	;	write "$ZLevel = ",$ZLevel,$char(9)
	;	write "ZTLevel = ",$ZTLevel,!
	;	ztrigger ^forced("inchains")
	;	write ?4,"I am ",$ZTNAme,$char(9)
	;	write "$ZLevel = ",$ZLevel,$char(9)
	;	write "ZTLevel = ",$ZTLevel,!
	;	quit
	;>>
	;;----------------------------------------------------------------
	;; switch between trigger levels
	;+^levelchange(lvn=:) -command=ZTR -xecute=<<
	;	write $i(nonce),?4,"I am ",$ZTNAme,$char(9)
	;	write "$ZLevel = ",$ZLevel,$char(9)
	;	write "ZTLevel = ",$ZTLevel,!
	;	if nonce>2 write "My nonce is too high",! quit
	;
	;; when (lvn="repeat") zgoto back to the trigger invocation
	;; to show that doing so restarts the trigger code. Avoid
	;; looping with the nonce local var. note the hard coded
	;; $zlevel 3 in the zgoto
	;retrigger
	;	if $ztlevel<5 ztrigger ^levelchange(lvn)
	;	goto:$zlevel<4 done
	;	write "Dropping down from ",$zlevel," to 3",!
	;	if lvn="repeat" zgoto 3:^@$ZTNAme
	;	else  zgoto 3:done^@$ZTNAme
	;done
	;	write nonce,?4,"I am ",$ZTNAme,$char(9)
	;	write "$ZLevel = ",$ZLevel,$char(9)
	;	write "ZTLevel = ",$ZTLevel,!
	;	quit
	;>>
